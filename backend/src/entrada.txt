
println!("{}",!false);
let aprint="Prueba print ";
println!("{}",aprint);
println!("{} que tal soy {}","Hola","Soy Manuel");

println!(false);

let mut hola  = 123;
println!("{}",hola);
hola = hola +1 ;
println!("{}",hola);

if 5==6 {
    println!("ma√±ana");
} else if 8==8 {
    println!("fer");
} else {
     println!("ayer");
};

let x= if 3==3 { 11 } else if 4<2 { 20 } else if 6<4 { 30 } else { 80 };
println!("{}",x);


match x {
    40 => {println!("hola");}
    80|10|5 =>  println!("90 en match \n \"manzana\""),

    _=>
        println!("90 en match x  dssd"),

};

let a= match x {
    10 => "hola",
    11 => "11 x match iteracion",
    _=> "que tal",
};
println!("{}",a);

let mut cont = 0;
loop {
    cont=cont+1;
    if cont!=3 {
        println!("prueba loop norm");
    }else{
        break;
    };
};

let mut p1 = 2;
let mut p3 = loop {
    p1=p1-1;

    if p1==0{
        break "Loop ternario bien";
    }else{
        println!("{}",p1);
        println!("---prueba loop ---");
    };
};
println!("{}",p3);

let mut pruebaW=0;
while pruebaW<3 {
    println!("it while");
    pruebaW=pruebaW+1;
};
println!("{}",pruebaW);

fn Funcion1 () {
    println!("hola");
};

//Nativas--------------------------
let sprueba : String = "holamundo".to_string();
let sprueba2 : &str = " prueba string";
println!("Prueba concatenacion: {}",sprueba+sprueba2);

let prueba : i64 =-64.abs();
println!("prueba abs: {}",prueba);

let manx: f64 = (32 as f64).sqrt();
println!("prueba sqrt: {}",manx);

let hi = "fer".clone();
println!("prueba clone: {}",hi);

// HOla que tla mucho gusto
Funcion1();

fn multi (mut x:i64, y:i64)->i64{

    x= x*y;

    println!("{}",x);
    return x;
};
let y=multi(2,3);
println!("El resultado de multi es: {}",y);

//Vectores
let mut vnew: Vec<i64> = Vec::new();
let vnew2: Vec<i64> = Vec::new();



//arreglos
let mut arreglo1 = ["hola","que tal", "jijo"];
let arr2 = [
[ [ 1, 3, 5, 7], [ 9, 11, 13, 15] ],
[ [ 2, 4, 6, 8], [10, 12, 14, 16] ]
];
//let arr1: [&str; 4] = ["Hola"; 4]; // ["Hola", "Hola", "Hola", "Hola"];
let arr2p: [[&str;2];2] = [["Hola","hola"],["Hola","hola"]];
let arre2p1: [[&str;4];2] = [["Hola","hola","hola","hola"],["Hola","hola","hola","hola"]];
let arre2p2: [[[&str;5];2];2] = [
[["Hola","hola","hola","hola"],["Hola","hola","hola","hola"]],
[["Hola","hola","hola","hola"],["Hola","hola","hola","hola"]]
];

let vcap: Vec<i64> = Vec::with_capacity(10);
let mut vcap2: Vec<i64> = Vec::with_capacity(10);


let vveci = vec![2,4,6,8,10];
let vveci2 = vec![2;10];

let mut vveci3 = vec! [2,3,4,vec![3;2]];
vveci3.push(12);
vveci3.insert(0,34);
let pvec=vveci3.remove(0);
println!("remove vector: {}",pvec);
let mut pvec2:bool = vveci3.contains(&2); //siempre deben de ir con & los valores a buscar
println!("Contains es true: {}",pvec2);
println!("len : {}",vveci3.len());

println!("vector decarado con capacity, Capacity : {}",vcap.capacity());
println!("vector decarado sin capacity, Capacity : {}",vveci3.capacity());

//Acceso a los datos de los arreglos
let acces = vveci3[0];
println!("Contenido de vveci3 en pos 0: {}",acces);