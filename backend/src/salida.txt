#include <stdio.h>
float HEAP[78000];
float STACK[10000];
float P;
float H;
float t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,t17,t18,t19,t20,t21,t22,t23,t24,t25,t26,t27,t28,t29,t30,t31,t32,t33,t34,t35,t36,t37,t38,t39,t40,t41,t42,t43,t44,t45,t46,t47,t48,t49,t50,t51,t52,t53,t54,t55,t56,t57,t58,t59,t60,t61,t62,t63,t64,t65,t66,t67,t68,t69,t70,t71,t72,t73,t74,t75,t76,t77,t78,t79,t80,t81,t82,t83,t84,t85,t86,t87,t88,t89,t90,t91,t92,t93,t94,t95,t96,t97,t98,t99,t100,t101,t102,t103,t104,t105,t106,t107,t108,t109,t110,t111,t112,t113,t114,t115,t116,t117,t118,t119,t120,t121,t122,t123,t124,t125,t126,t127,t128,t129,t130,t131,t132,t133,t134,t135,t136,t137,t138,t139,t140,t141,t142,t143,t144,t145,t146,t147,t148,t149,t150,t151,t152,t153,t154,t155,t156,t157,t158,t159,t160,t161,t162,t163,t164,t165,t166,t167,t168,t169,t170,t171,t172,t173,t174,t175,t176,t177,t178,t179,t180,t181,t182,t183,t184,t185,t186,t187,t188,t189,t190,t191,t192,t193,t194,t195,t196,t197,t198,t199,t200,t201,t202,t203,t204,t205,t206,t207,t208,t209,t210,t211,t212,t213,t214,t215,t216,t217,t218,t219,t220,t221,t222,t223,t224,t225,t226,t227,t228,t229,t230,t231,t232,t233,t234,t235,t236,t237,t238,t239,t240,t241,t242,t243,t244,t245,t246,t247,t248,t249,t250,t251,t252,t253,t254,t255,t256,t257,t258,t259,t260,t261,t262,t263,t264,t265,t266,t267,t268,t269,t270,t271,t272,t273,t274,t275,t276,t277,t278,t279,t280,t281,t282,t283,t284,t285,t286,t287,t288,t289,t290,t291,t292,t293,t294,t295,t296,t297,t298,t299,t300,t301,t302,t303,t304,t305,t306,t307,t308,t309,t310,t311,t312,t313,t314,t315,t316,t317,t318,t319,t320,t321,t322,t323,t324,t325,t326,t327,t328,t329,t330,t331,t332,t333,t334,t335,t336,t337,t338,t339,t340,t341,t342,t343,t344,t345,t346,t347,t348,t349,t350,t351,t352,t353,t354,t355,t356,t357,t358,t359,t360,t361,t362,t363,t364,t365,t366,t367,t368,t369,t370,t371,t372,t373,t374,t375,t376,t377,t378,t379,t380,t381,t382,t383,t384,t385,t386,t387,t388,t389,t390,t391,t392,t393,t394,t395,t396,t397,t398,t399,t400,t401,t402,t403,t404,t405,t406,t407,t408,t409,t410,t411,t412,t413,t414,t415,t416,t417,t418,t419,t420,t421,t422,t423,t424,t425,t426,t427,t428,t429,t430,t431,t432,t433,t434,t435,t436,t437,t438,t439,t440,t441,t442,t443,t444,t445,t446,t447,t448,t449,t450,t451,t452,t453,t454,t455,t456,t457,t458,t459,t460,t461,t462,t463,t464,t465,t466,t467,t468,t469,t470,t471,t472,t473,t474,t475,t476,t477,t478,t479,t480,t481,t482,t483,t484,t485,t486,t487,t488,t489,t490,t491,t492,t493,t494,t495,t496,t497,t498,t499,t500,t501,t502,t503,t504,t505,t506,t507,t508,t509,t510,t511,t512,t513,t514,t515,t516,t517,t518,t519,t520,t521,t522,t523,t524,t525,t526,t527,t528,t529,t530,t531,t532,t533,t534,t535,t536,t537,t538,t539,t540,t541,t542,t543,t544,t545,t546,t547,t548,t549,t550,t551,t552,t553,t554,t555,t556,t557,t558,t559,t560,t561,t562,t563,t564,t565,t566,t567,t568,t569,t570,t571,t572,t573,t574,t575,t576,t577,t578,t579,t580,t581,t582,t583,t584,t585,t586,t587,t588,t589,t590,t591,t592,t593,t594,t595,t596,t597,t598,t599,t600,t601,t602,t603,t604,t605,t606,t607,t608,t609,t610,t611,t612,t613,t614,t615,t616,t617,t618,t619,t620,t621,t622,t623,t624,t625,t626,t627,t628,t629,t630,t631,t632,t633,t634,t635,t636,t637,t638,t639,t640,t641,t642,t643,t644,t645,t646,t647,t648,t649,t650,t651,t652,t653,t654,t655,t656,t657,t658,t659,t660,t661,t662,t663,t664,t665,t666,t667,t668,t669,t670,t671,t672,t673,t674,t675,t676,t677,t678,t679,t680,t681,t682,t683,t684,t685,t686,t687,t688,t689,t690,t691,t692,t693,t694,t695,t696,t697,t698,t699,t700,t701,t702,t703,t704,t705,t706,t707,t708,t709,t710,t711,t712,t713,t714,t715,t716,t717,t718,t719,t720,t721,t722,t723,t724,t725,t726,t727,t728,t729,t730,t731,t732,t733,t734,t735,t736,t737,t738,t739,t740,t741,t742,t743,t744,t745,t746,t747,t748,t749,t750,t751,t752,t753,t754,t755,t756,t757,t758,t759,t760,t761,t762,t763,t764,t765,t766,t767,t768,t769,t770,t771,t772,t773,t774,t775,t776,t777,t778,t779,t780,t781,t782,t783,t784,t785,t786,t787,t788,t789,t790,t791,t792,t793,t794,t795,t796,t797,t798,t799,t800,t801,t802,t803,t804,t805,t806,t807,t808,t809,t810,t811,t812,t813,t814,t815,t816,t817,t818,t819,t820,t821,t822,t823,t824,t825,t826,t827,t828,t829,t830,t831,t832,t833,t834,t835,t836,t837,t838,t839,t840,t841,t842,t843,t844,t845,t846,t847,t848,t849,t850,t851,t852,t853,t854,t855,t856,t857,t858,t859,t860,t861,t862,t863,t864,t865,t866,t867,t868,t869,t870,t871,t872,t873,t874,t875,t876,t877,t878,t879,t880,t881,t882,t883,t884,t885,t886,t887,t888,t889,t890,t891,t892,t893,t894,t895,t896,t897,t898,t899,t900,t901,t902,t903,t904,t905,t906,t907,t908,t909,t910,t911,t912,t913,t914,t915,t916,t917,t918,t919,t920,t921,t922,t923,t924,t925,t926,t927,t928,t929,t930,t931,t932,t933,t934,t935,t936,t937,t938,t939,t940,t941,t942,t943,t944,t945,t946,t947,t948,t949,t950,t951,t952,t953,t954,t955,t956,t957,t958,t959,t960,t961,t962,t963,t964,t965,t966,t967,t968,t969,t970,t971,t972,t973,t974,t975,t976,t977,t978,t979,t980,t981,t982,t983,t984,t985,t986,t987,t988,t989,t990,t991,t992,t993,t994,t995,t996,t997,t998,t999,t1000,t1001,t1002,t1003,t1004,t1005,t1006,t1007,t1008,t1009,t1010,t1011,t1012,t1013,t1014,t1015,t1016,t1017,t1018,t1019,t1020,t1021,t1022,t1023,t1024,t1025,t1026,t1027,t1028,t1029,t1030,t1031,t1032,t1033,t1034,t1035,t1036,t1037,t1038,t1039,t1040,t1041,t1042,t1043,t1044,t1045,t1046,t1047,t1048,t1049,t1050,t1051,t1052,t1053,t1054,t1055,t1056,t1057,t1058,t1059,t1060,t1061,t1062,t1063,t1064,t1065,t1066,t1067,t1068,t1069,t1070,t1071,t1072,t1073,t1074,t1075,t1076,t1077,t1078,t1079,t1080,t1081,t1082,t1083,t1084,t1085,t1086,t1087,t1088,t1089,t1090,t1091,t1092,t1093,t1094,t1095,t1096,t1097,t1098,t1099,t1100,t1101,t1102,t1103,t1104,t1105,t1106,t1107,t1108,t1109,t1110,t1111,t1112,t1113,t1114,t1115,t1116,t1117,t1118,t1119,t1120,t1121,t1122,t1123,t1124,t1125,t1126,t1127,t1128,t1129,t1130,t1131,t1132,t1133,t1134,t1135,t1136,t1137,t1138,t1139,t1140,t1141,t1142,t1143,t1144,t1145,t1146,t1147,t1148,t1149,t1150,t1151,t1152,t1153,t1154,t1155,t1156,t1157,t1158,t1159,t1160,t1161,t1162,t1163,t1164,t1165,t1166,t1167,t1168,t1169,t1170,t1171,t1172,t1173,t1174,t1175,t1176,t1177,t1178,t1179,t1180,t1181,t1182,t1183;

void apilar(){{
/* If instruction */
/* Operaciones Relacionales */
/* Len de Vector vec */
t35 = 0;
P = P - t35;
t40 = P + 2;
P = P + t35;
t39 = STACK[(int)t40];
t39 = STACK[(int)t39];
t34 = HEAP[(int)t39 ];
/* End Len */
/* ID EXPRESION: capacidad */
t41 = 0;
P = P - t41;
t43 = P + 1;
P = P + t41;
t42 = STACK[(int)t43];
if(t34 < t42) goto L7;
goto L8;
L7:
P = P + 4;
/* Insert en Vector vec */
t44 = 0;
t44 = t44 + 4;
/* ID EXPRESION: value */
t45 = 0;
t45 = t45 + 4;
P = P - t45;
t47 = P + 3;
P = P + t45;
t46 = STACK[(int)t47];
/* Len de Vector vec */
t49 = 0;
t49 = t49 + 4;
P = P - t49;
t54 = P + 2;
P = P + t49;
t53 = STACK[(int)t54];
t53 = STACK[(int)t53];
t48 = HEAP[(int)t53 ];
/* End Len */
t55 = t46;
t62 = t48;
if(t62 < 0) goto L19;
P = P - t44;
t63 = P + 2;
P = P + t44;
t56 = STACK[(int)t63];
t56 = STACK[(int)t56];
t57 = HEAP[(int)t56 ];
t56 = t56 + 1;
t60 = HEAP[(int)t56 ];
t56 = t56 + 1;
/* Si la capacidad es 0 */
if(t60 != 0) goto L21;
t60 = 4;
L21:
/* Si el tamanio es igual o mayor a capacity */
if(t57 < t60) goto L20;
t60 = t60 * 2;
L20:
if(t62 > t57) goto L19;
t61 = 0;
t63 = STACK[(int)t63];
STACK[(int)t63] = H;
t58 = t57 + 1;
/* New tamanio */
HEAP[(int)H] = t58;
H = H + 1;
/* New Capacity */
HEAP[(int)H] = t60;
H = H + 1;
L16:
if(t61 >= t62) goto L18;
t59 = HEAP[(int)t56 ];
HEAP[(int)H] = t59;
t56 = t56 + 1;
t61 = t61 + 1;
H = H + 1;
goto L16;
L18:
HEAP[(int)H] = t55;
H = H + 1;
L15:
if(t61 >= t57) goto L17;
t59 = HEAP[(int)t56 ];
HEAP[(int)H] = t59;
H = H + 1;
t56 = t56 + 1;
t61 = t61 + 1;
goto L15;
L19:
printf("%c",66);
printf("%c",111);
printf("%c",117);
printf("%c",110);
printf("%c",100);
printf("%c",115);
printf("%c",32);
printf("%c",69);
printf("%c",114);
printf("%c",114);
printf("%c",111);
printf("%c",114);
printf("%c",10);
L17:
/* End Insert */
P = P - 4;
goto L9;
L8:
P = P + 4;
/* Primitivo tipo STR: "La pila ha llegado a su maxima capacidad" */
t64 = H  ;
HEAP[(int)H] = 76;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 112;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 104;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 103;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = 117;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 109;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 120;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 109;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 99;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 112;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 99;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Print de un String o CHAR */
t65 = t64  ;
L22:
t66 = HEAP[(int)t65 ];
if(t66 != -1) goto L23;
goto L24;
L23:
printf("%c",(char)t66);
t65 = t65 + 1;
goto L22;
L24:
printf("%c",10);
P = P - 4;
L9:
/* End If */
L6:
return; 
}} 

void pila_vacia(){{
/* Retorno de Expresion sin Return */
t107 = P + 0;
/* Operaciones Relacionales */
/* Len de Vector vec */
t109 = 0;
P = P - t109;
t114 = P + 1;
P = P + t109;
t113 = STACK[(int)t114];
t113 = STACK[(int)t113];
t108 = HEAP[(int)t113 ];
/* End Len */
if(t108 == 0) goto L48;
goto L49;
L48:
STACK[(int)t107] = 1;
goto L53;
L49:
STACK[(int)t107] = 0;
L53:
goto L47;
L47:
return; 
}} 

void desapilar(){{
/* If instruction */
/* Logicas */
/* Logica: Not */
/* Llamada a funcion: pila_vacia */
/* Puntero a nuevo enviroment */
t102 = P + 2;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: vec */
t103 = 0;
P = P - t103;
t105 = P + 1;
P = P + t103;
t104 = STACK[(int)t105];
t106 = t102 + 1;
STACK[(int)t106] = t104;
P = P + 2;
pila_vacia();
P = P - 2;
/* Valor de return */
t115 = P + 2;
t116 = STACK[(int)t115];
if(t116 == 1) goto L45;
goto L44;
L44:
P = P + 2;
t117 = 0;
t117 = t117 + 2;
/* Index de la pos de Return */
/* Remove en Vector vec */
t120 = 0;
t120 = t120 + 2;
/* Aritmeticas */
/* Len de Vector vec */
t123 = 0;
t123 = t123 + 2;
P = P - t123;
t128 = P + 1;
P = P + t123;
t127 = STACK[(int)t128];
t127 = STACK[(int)t127];
t122 = HEAP[(int)t127 ];
/* End Len */
t121 = t122 - 1;
t135 = t121;
if(t135 < 0) goto L60;
P = P - t120;
t136 = P + 1;
P = P + t120;
t129 = STACK[(int)t136];
t129 = STACK[(int)t129];
t130 = HEAP[(int)t129 ];
t129 = t129 + 1;
t133 = HEAP[(int)t129 ];
t129 = t129 + 1;
if(t135 >= t130) goto L60;
if(t135 < 0) goto L60;
t136 = STACK[(int)t136];
t134 = 0;
STACK[(int)t136] = H;
/* New tamanio despues de remove */
t131 = t130 - 1;
HEAP[(int)H] = (int)t131;
H = H + 1;
/* New Capacity */
HEAP[(int)H] = t133;
H = H + 1;
L57:
if(t134 >= t135) goto L59;
t132 = HEAP[(int)t129 ];
HEAP[(int)H] = t132;
t129 = t129 + 1;
t134 = t134 + 1;
H = H + 1;
goto L57;
/* Valor a remover */
L59:
t119 = HEAP[(int)t129 ];
t129 = t129 + 1;
t134 = t134 + 1;
L56:
if(t134 >= t130) goto L58;
t132 = HEAP[(int)t129 ];
HEAP[(int)H] = t132;
H = H + 1;
t129 = t129 + 1;
t134 = t134 + 1;
goto L56;
L60:
printf("%c",66);
printf("%c",111);
printf("%c",117);
printf("%c",110);
printf("%c",100);
printf("%c",115);
printf("%c",32);
printf("%c",69);
printf("%c",114);
printf("%c",114);
printf("%c",111);
printf("%c",114);
printf("%c",10);
t119 = 0;
L58:
/* End remove */
/* Ingreso de valor a la Pos Return */
P = P - t117;
t118 = P + 0;
STACK[(int)t118] = t119;
goto L43;
P = P - 2;
goto L46;
L45:
P = P + 2;
/* Primitivo tipo STR: "La pila no tiene elementos" */
t137 = H  ;
HEAP[(int)H] = 76;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 112;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 110;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 110;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 109;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 110;
H = H + 1;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Print de un String o CHAR */
t138 = t137  ;
L61:
t139 = HEAP[(int)t138 ];
if(t139 != -1) goto L62;
goto L63;
L62:
printf("%c",(char)t139);
t138 = t138 + 1;
goto L61;
L63:
printf("%c",10);
P = P - 2;
L46:
/* End If */
/* Retorno de Expresion sin Return */
t140 = P + 0;
STACK[(int)t140] = 0;
goto L43;
L43:
return; 
}} 

void encolar(){{
/* If instruction */
/* Operaciones Relacionales */
/* Len de Vector vec */
t439 = 0;
P = P - t439;
t444 = P + 2;
P = P + t439;
t443 = STACK[(int)t444];
t443 = STACK[(int)t443];
t438 = HEAP[(int)t443 ];
/* End Len */
/* ID EXPRESION: capacidad */
t445 = 0;
P = P - t445;
t447 = P + 1;
P = P + t445;
t446 = STACK[(int)t447];
if(t438 < t446) goto L251;
goto L252;
L251:
P = P + 4;
/* Push Vector vec */
t448 = 0;
t448 = t448 + 4;
/* ID EXPRESION: value */
t449 = 0;
t449 = t449 + 4;
P = P - t449;
t451 = P + 3;
P = P + t449;
t450 = STACK[(int)t451];
t452 = t450;
P = P - t448;
t459 = P + 2;
P = P + t448;
t453 = STACK[(int)t459];
t453 = STACK[(int)t453];
t454 = HEAP[(int)t453 ];
t453 = t453 + 1;
t455 = HEAP[(int)t453 ];
t453 = t453 + 1;
/* Si la capacidad es 0 */
if(t455 != 0) goto L260;
t455 = 4;
L260:
/* Si el tamanio es igual o mayor a capacity */
if(t454 < t455) goto L259;
t455 = t455 * 2;
L259:
t458 = 0;
t459 = STACK[(int)t459];
STACK[(int)t459] = H;
/* New Tamanio */
t456 = t454 + 1;
HEAP[(int)H] = t456;
H = H + 1;
/* New Capacity */
HEAP[(int)H] = t455;
H = H + 1;
L257:
if(t458 >= t454) goto L258;
t457 = HEAP[(int)t453 ];
HEAP[(int)H] = t457;
H = H + 1;
t453 = t453 + 1;
t458 = t458 + 1;
goto L257;
L258:
HEAP[(int)H] = t452;
H = H + 1;
P = P - 4;
goto L253;
L252:
P = P + 4;
/* Primitivo tipo STR: "La cola ha llegado a su maxima capacidad" */
t460 = H  ;
HEAP[(int)H] = 76;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 99;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 104;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 103;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = 117;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 109;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 120;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 109;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 99;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 112;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 99;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Print de un String o CHAR */
t461 = t460  ;
L261:
t462 = HEAP[(int)t461 ];
if(t462 != -1) goto L262;
goto L263;
L262:
printf("%c",(char)t462);
t461 = t461 + 1;
goto L261;
L263:
printf("%c",10);
P = P - 4;
L253:
/* End If */
L250:
return; 
}} 

void cola_vacia(){{
/* Retorno de Expresion sin Return */
t503 = P + 0;
/* Operaciones Relacionales */
/* Len de Vector vec */
t505 = 0;
P = P - t505;
t510 = P + 1;
P = P + t505;
t509 = STACK[(int)t510];
t509 = STACK[(int)t509];
t504 = HEAP[(int)t509 ];
/* End Len */
if(t504 == 0) goto L287;
goto L288;
L287:
STACK[(int)t503] = 1;
goto L292;
L288:
STACK[(int)t503] = 0;
L292:
goto L286;
L286:
return; 
}} 

void desencolar(){{
/* If instruction */
/* Logicas */
/* Logica: Not */
/* Llamada a funcion: cola_vacia */
/* Puntero a nuevo enviroment */
t498 = P + 2;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: vec */
t499 = 0;
P = P - t499;
t501 = P + 1;
P = P + t499;
t500 = STACK[(int)t501];
t502 = t498 + 1;
STACK[(int)t502] = t500;
P = P + 2;
cola_vacia();
P = P - 2;
/* Valor de return */
t511 = P + 2;
t512 = STACK[(int)t511];
if(t512 == 1) goto L284;
goto L283;
L283:
P = P + 2;
t513 = 0;
t513 = t513 + 2;
/* Index de la pos de Return */
/* Remove en Vector vec */
t516 = 0;
t516 = t516 + 2;
t523 = 0;
if(t523 < 0) goto L297;
P = P - t516;
t524 = P + 1;
P = P + t516;
t517 = STACK[(int)t524];
t517 = STACK[(int)t517];
t518 = HEAP[(int)t517 ];
t517 = t517 + 1;
t521 = HEAP[(int)t517 ];
t517 = t517 + 1;
if(t523 >= t518) goto L297;
if(t523 < 0) goto L297;
t524 = STACK[(int)t524];
t522 = 0;
STACK[(int)t524] = H;
/* New tamanio despues de remove */
t519 = t518 - 1;
HEAP[(int)H] = (int)t519;
H = H + 1;
/* New Capacity */
HEAP[(int)H] = t521;
H = H + 1;
L294:
if(t522 >= t523) goto L296;
t520 = HEAP[(int)t517 ];
HEAP[(int)H] = t520;
t517 = t517 + 1;
t522 = t522 + 1;
H = H + 1;
goto L294;
/* Valor a remover */
L296:
t515 = HEAP[(int)t517 ];
t517 = t517 + 1;
t522 = t522 + 1;
L293:
if(t522 >= t518) goto L295;
t520 = HEAP[(int)t517 ];
HEAP[(int)H] = t520;
H = H + 1;
t517 = t517 + 1;
t522 = t522 + 1;
goto L293;
L297:
printf("%c",66);
printf("%c",111);
printf("%c",117);
printf("%c",110);
printf("%c",100);
printf("%c",115);
printf("%c",32);
printf("%c",69);
printf("%c",114);
printf("%c",114);
printf("%c",111);
printf("%c",114);
printf("%c",10);
t515 = 0;
L295:
/* End remove */
/* Ingreso de valor a la Pos Return */
P = P - t513;
t514 = P + 0;
STACK[(int)t514] = t515;
goto L282;
P = P - 2;
goto L285;
L284:
P = P + 2;
/* Primitivo tipo STR: "La cola no tiene elementos" */
t525 = H  ;
HEAP[(int)H] = 76;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 99;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 110;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 110;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 109;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 110;
H = H + 1;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Print de un String o CHAR */
t526 = t525  ;
L298:
t527 = HEAP[(int)t526 ];
if(t527 != -1) goto L299;
goto L300;
L299:
printf("%c",(char)t527);
t526 = t526 + 1;
goto L298;
L300:
printf("%c",10);
P = P - 2;
L285:
/* End If */
/* Retorno de Expresion sin Return */
t528 = P + 0;
STACK[(int)t528] = 0;
goto L282;
L282:
return; 
}} 

int main(){
/* Declaracion var: capacidad */
/* Ingreso a la Pila */
t0 = P + 0;
STACK[(int)t0] = 10;
/* Declaracion de Vector: pila */
/* Vector con Capacity */
/* Aritmeticas */
/* ID EXPRESION: capacidad */
t2 = 0;
P = P - t2;
t4 = P + 0;
P = P + t2;
t3 = STACK[(int)t4];
t1 = t3 - 2;
t5 = H;
/* Tamanio del Vector */
HEAP[(int)H] = 0;
H = H + 1;
/* Capacity */
HEAP[(int)H] = t1;
H = H + 1;
/* ------------------ */
t6 = P + 1;
STACK[(int)t6] = t5;
/* Declaracion de Vector: cola */
/* Vector con vec! */
/* Exp Vec! */
t7 = H;
/* Tamanio Vec! */
HEAP[(int)H] = 5;
H = H + 1;
/* --------------- */
/* Capacity del vec */
HEAP[(int)H] = 5;
H = H + 1;
/* --------------- */
HEAP[(int)H] = 1;
H = H + 1;
HEAP[(int)H] = 2;
H = H + 1;
HEAP[(int)H] = 3;
H = H + 1;
HEAP[(int)H] = 4;
H = H + 1;
HEAP[(int)H] = 5;
H = H + 1;
t8 = P + 2;
STACK[(int)t8] = t7;
/* Declaracion de arreglo: datos */
/* Dimensionales del arreglo */
t9 = 5;
/* ------------------------ */
/* Exp Arreglo */
t10 = H;
/* Tamanio Arreglo */
HEAP[(int)H] = 5;
/* --------------- */
H = H + 1;
HEAP[(int)H] = 10;
H = H + 1;
HEAP[(int)H] = 20;
H = H + 1;
HEAP[(int)H] = 30;
H = H + 1;
HEAP[(int)H] = 40;
H = H + 1;
HEAP[(int)H] = 50;
H = H + 1;
t11 = P + 3;
STACK[(int)t11] = t10;
/* FOR IN */
P = P + 4;
/* ID EXPRESION: datos */
t12 = 0;
t12 = t12 + 4;
P = P - t12;
t14 = P + 3;
P = P + t12;
t13 = STACK[(int)t14];
t17 = t13;
/* Tcont */
t18 = -1;
/* tamanio */
t19 = HEAP[(int)t17 ];
t17 = t17 + 1;
/* Loop del For */
L2:
t18 = t18 + 1;
if(t18 >= t19) goto L3;
t20 = t17 + t18;
t15 = HEAP[(int)t20 ];
t16 = P + 0;
STACK[(int)t16] = t15;
/* Instrucciones For */
/* Llamada a funcion: apilar */
/* Puntero a nuevo enviroment */
t21 = P + 1;
/* Declaracion var: capacidad */
/* ID EXPRESION: capacidad */
t22 = 0;
t22 = t22 + 4;
P = P - t22;
t24 = P + 0;
P = P + t22;
t23 = STACK[(int)t24];
/* Ingreso a la Pila */
t25 = t21 + 1;
STACK[(int)t25] = t23;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t26 = 0;
t26 = t26 + 4;
P = P - t26;
t27 = P + 1;
P = P + t26;
t28 = t21 + 2;
STACK[(int)t28] = (int)t27;
/* Declaracion var: value */
/* ID EXPRESION: dato */
t29 = 0;
P = P - t29;
t31 = P + 0;
P = P + t29;
t30 = STACK[(int)t31];
/* Ingreso a la Pila */
t32 = t21 + 3;
STACK[(int)t32] = t30;
P = P + 1;
apilar();
P = P - 1;
/* Valor de return */
t67 = P + 1;
t68 = STACK[(int)t67];
goto L2;
L3:
P = P - 4;
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t69 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* ID EXPRESION: pila */
t71 = 0;
P = P - t71;
t73 = P + 1;
P = P + t71;
t72 = STACK[(int)t73];
/* Para saber donde iniciar a imprimir luego del proceso */
t70 = H;
/* Print Complex P.1 */
t74 = t69  ;
L25:
t75 = HEAP[(int)t74 ];
if(t75 == (char)123) goto L28;
HEAP[(int)H] = t75;
H = H + 1;
t74 = t74 + 1;
goto L25;
/* Print Complex P.2 */
L28:
t74 = t74 + 1;
L26:
t75 = HEAP[(int)t74 ];
if(t75 == (char)125) goto L29;
t74 = t74 + 1;
goto L26;
/* Print Complex P.3 */
L29:
t74 = t74 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof 1 */
t80 = 0;
t76 = t72;
/* Tamanio */
t79 = HEAP[(int)t76 ];
t76 = t76 + 1;
t76 = t76 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L31:
if(t80 >= t79) goto L32;
t78 = t76 + t80;
t77 = HEAP[(int)t78 ];
/* Num to String */
t82 = t77;
/* Por si es Negativo  */
if(t82 >= 0) goto L33;
t82 = t82 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L33:
t83 = H;
t84 = t82  ;
L34:
t85 = t84 / 10;
t86 = (int)t85;
if(t86 == 0) goto L35;
t87 = (int)t84%10;
t84 = t86;
HEAP[(int)H] = (int)t87 +48;
H = H + 1;
goto L34;
L35:
HEAP[(int)H] = (int)t84+48;
H = H + 1;
/* sort_revers */
t88 = t83;
t89 = H-1;
L36:
if(t88 >= t89) goto L37;
t90 = HEAP[(int)t89 ];
t91 = HEAP[(int)t88 ];
HEAP[(int)t88] = t90;
HEAP[(int)t89] = t91;
t88 = t88 + 1;
t89 = t89 - 1;
goto L36;
L37:
t80 = t80 + 1;
/* Para evitar poner una comma extra */
if(t80 >= t79) goto t81;
HEAP[(int)H] = 44;
H = H + 1;
t81:
goto L31;
L32:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L27:
t75 = HEAP[(int)t74 ];
if(t75 == -1) goto L30;
HEAP[(int)H] = t75;
H = H + 1;
t74 = t74 + 1;
goto L27;
/* Salida print Complex */
L30:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t93 = t70  ;
L38:
t94 = HEAP[(int)t93 ];
if(t94 != -1) goto L39;
goto L40;
L39:
printf("%c",(char)t94);
t93 = t93 + 1;
goto L38;
L40:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t95 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desapilar */
/* Puntero a nuevo enviroment */
t97 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t98 = 0;
P = P - t98;
t99 = P + 1;
P = P + t98;
t100 = t97 + 1;
STACK[(int)t100] = (int)t99;
P = P + 4;
desapilar();
P = P - 4;
/* Valor de return */
t141 = P + 4;
t142 = STACK[(int)t141];
/* Para saber donde iniciar a imprimir luego del proceso */
t96 = H;
/* Print Complex P.1 */
t143 = t95  ;
L64:
t144 = HEAP[(int)t143 ];
if(t144 == (char)123) goto L67;
HEAP[(int)H] = t144;
H = H + 1;
t143 = t143 + 1;
goto L64;
/* Print Complex P.2 */
L67:
t143 = t143 + 1;
L65:
t144 = HEAP[(int)t143 ];
if(t144 == (char)125) goto L68;
t143 = t143 + 1;
goto L65;
/* Print Complex P.3 */
L68:
t143 = t143 + 1;
/* Num to String */
t145 = t142;
/* Por si es Negativo  */
if(t145 >= 0) goto L70;
t145 = t145 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L70:
t146 = H;
t147 = t145  ;
L71:
t148 = t147 / 10;
t149 = (int)t148;
if(t149 == 0) goto L72;
t150 = (int)t147%10;
t147 = t149;
HEAP[(int)H] = (int)t150 +48;
H = H + 1;
goto L71;
L72:
HEAP[(int)H] = (int)t147+48;
H = H + 1;
/* sort_revers */
t151 = t146;
t152 = H-1;
L73:
if(t151 >= t152) goto L74;
t153 = HEAP[(int)t152 ];
t154 = HEAP[(int)t151 ];
HEAP[(int)t151] = t153;
HEAP[(int)t152] = t154;
t151 = t151 + 1;
t152 = t152 - 1;
goto L73;
L74:
/* Print Complex P.4 */
L66:
t144 = HEAP[(int)t143 ];
if(t144 == -1) goto L69;
HEAP[(int)H] = t144;
H = H + 1;
t143 = t143 + 1;
goto L66;
/* Salida print Complex */
L69:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t156 = t96  ;
L75:
t157 = HEAP[(int)t156 ];
if(t157 != -1) goto L76;
goto L77;
L76:
printf("%c",(char)t157);
t156 = t156 + 1;
goto L75;
L77:
printf("%c",10);
/* Llamada a funcion: apilar */
/* Puntero a nuevo enviroment */
t158 = P + 4;
/* Declaracion var: capacidad */
/* ID EXPRESION: capacidad */
t159 = 0;
P = P - t159;
t161 = P + 0;
P = P + t159;
t160 = STACK[(int)t161];
/* Ingreso a la Pila */
t162 = t158 + 1;
STACK[(int)t162] = t160;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t163 = 0;
P = P - t163;
t164 = P + 1;
P = P + t163;
t165 = t158 + 2;
STACK[(int)t165] = (int)t164;
/* Declaracion var: value */
/* Ingreso a la Pila */
t166 = t158 + 3;
STACK[(int)t166] = 1250;
P = P + 4;
apilar();
P = P - 4;
/* Valor de return */
t167 = P + 4;
t168 = STACK[(int)t167];
/* Llamada a funcion: apilar */
/* Puntero a nuevo enviroment */
t169 = P + 4;
/* Declaracion var: capacidad */
/* ID EXPRESION: capacidad */
t170 = 0;
P = P - t170;
t172 = P + 0;
P = P + t170;
t171 = STACK[(int)t172];
/* Ingreso a la Pila */
t173 = t169 + 1;
STACK[(int)t173] = t171;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t174 = 0;
P = P - t174;
t175 = P + 1;
P = P + t174;
t176 = t169 + 2;
STACK[(int)t176] = (int)t175;
/* Declaracion var: value */
/* Ingreso a la Pila */
t177 = t169 + 3;
STACK[(int)t177] = 2200;
P = P + 4;
apilar();
P = P - 4;
/* Valor de return */
t178 = P + 4;
t179 = STACK[(int)t178];
/* Llamada a funcion: apilar */
/* Puntero a nuevo enviroment */
t180 = P + 4;
/* Declaracion var: capacidad */
/* ID EXPRESION: capacidad */
t181 = 0;
P = P - t181;
t183 = P + 0;
P = P + t181;
t182 = STACK[(int)t183];
/* Ingreso a la Pila */
t184 = t180 + 1;
STACK[(int)t184] = t182;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t185 = 0;
P = P - t185;
t186 = P + 1;
P = P + t185;
t187 = t180 + 2;
STACK[(int)t187] = (int)t186;
/* Declaracion var: value */
/* Ingreso a la Pila */
t188 = t180 + 3;
STACK[(int)t188] = 3500;
P = P + 4;
apilar();
P = P - 4;
/* Valor de return */
t189 = P + 4;
t190 = STACK[(int)t189];
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t191 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desapilar */
/* Puntero a nuevo enviroment */
t193 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t194 = 0;
P = P - t194;
t195 = P + 1;
P = P + t194;
t196 = t193 + 1;
STACK[(int)t196] = (int)t195;
P = P + 4;
desapilar();
P = P - 4;
/* Valor de return */
t197 = P + 4;
t198 = STACK[(int)t197];
/* Para saber donde iniciar a imprimir luego del proceso */
t192 = H;
/* Print Complex P.1 */
t199 = t191  ;
L86:
t200 = HEAP[(int)t199 ];
if(t200 == (char)123) goto L89;
HEAP[(int)H] = t200;
H = H + 1;
t199 = t199 + 1;
goto L86;
/* Print Complex P.2 */
L89:
t199 = t199 + 1;
L87:
t200 = HEAP[(int)t199 ];
if(t200 == (char)125) goto L90;
t199 = t199 + 1;
goto L87;
/* Print Complex P.3 */
L90:
t199 = t199 + 1;
/* Num to String */
t201 = t198;
/* Por si es Negativo  */
if(t201 >= 0) goto L92;
t201 = t201 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L92:
t202 = H;
t203 = t201  ;
L93:
t204 = t203 / 10;
t205 = (int)t204;
if(t205 == 0) goto L94;
t206 = (int)t203%10;
t203 = t205;
HEAP[(int)H] = (int)t206 +48;
H = H + 1;
goto L93;
L94:
HEAP[(int)H] = (int)t203+48;
H = H + 1;
/* sort_revers */
t207 = t202;
t208 = H-1;
L95:
if(t207 >= t208) goto L96;
t209 = HEAP[(int)t208 ];
t210 = HEAP[(int)t207 ];
HEAP[(int)t207] = t209;
HEAP[(int)t208] = t210;
t207 = t207 + 1;
t208 = t208 - 1;
goto L95;
L96:
/* Print Complex P.4 */
L88:
t200 = HEAP[(int)t199 ];
if(t200 == -1) goto L91;
HEAP[(int)H] = t200;
H = H + 1;
t199 = t199 + 1;
goto L88;
/* Salida print Complex */
L91:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t212 = t192  ;
L97:
t213 = HEAP[(int)t212 ];
if(t213 != -1) goto L98;
goto L99;
L98:
printf("%c",(char)t213);
t212 = t212 + 1;
goto L97;
L99:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t214 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desapilar */
/* Puntero a nuevo enviroment */
t216 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t217 = 0;
P = P - t217;
t218 = P + 1;
P = P + t217;
t219 = t216 + 1;
STACK[(int)t219] = (int)t218;
P = P + 4;
desapilar();
P = P - 4;
/* Valor de return */
t220 = P + 4;
t221 = STACK[(int)t220];
/* Para saber donde iniciar a imprimir luego del proceso */
t215 = H;
/* Print Complex P.1 */
t222 = t214  ;
L102:
t223 = HEAP[(int)t222 ];
if(t223 == (char)123) goto L105;
HEAP[(int)H] = t223;
H = H + 1;
t222 = t222 + 1;
goto L102;
/* Print Complex P.2 */
L105:
t222 = t222 + 1;
L103:
t223 = HEAP[(int)t222 ];
if(t223 == (char)125) goto L106;
t222 = t222 + 1;
goto L103;
/* Print Complex P.3 */
L106:
t222 = t222 + 1;
/* Num to String */
t224 = t221;
/* Por si es Negativo  */
if(t224 >= 0) goto L108;
t224 = t224 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L108:
t225 = H;
t226 = t224  ;
L109:
t227 = t226 / 10;
t228 = (int)t227;
if(t228 == 0) goto L110;
t229 = (int)t226%10;
t226 = t228;
HEAP[(int)H] = (int)t229 +48;
H = H + 1;
goto L109;
L110:
HEAP[(int)H] = (int)t226+48;
H = H + 1;
/* sort_revers */
t230 = t225;
t231 = H-1;
L111:
if(t230 >= t231) goto L112;
t232 = HEAP[(int)t231 ];
t233 = HEAP[(int)t230 ];
HEAP[(int)t230] = t232;
HEAP[(int)t231] = t233;
t230 = t230 + 1;
t231 = t231 - 1;
goto L111;
L112:
/* Print Complex P.4 */
L104:
t223 = HEAP[(int)t222 ];
if(t223 == -1) goto L107;
HEAP[(int)H] = t223;
H = H + 1;
t222 = t222 + 1;
goto L104;
/* Salida print Complex */
L107:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t235 = t215  ;
L113:
t236 = HEAP[(int)t235 ];
if(t236 != -1) goto L114;
goto L115;
L114:
printf("%c",(char)t236);
t235 = t235 + 1;
goto L113;
L115:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t237 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desapilar */
/* Puntero a nuevo enviroment */
t239 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t240 = 0;
P = P - t240;
t241 = P + 1;
P = P + t240;
t242 = t239 + 1;
STACK[(int)t242] = (int)t241;
P = P + 4;
desapilar();
P = P - 4;
/* Valor de return */
t243 = P + 4;
t244 = STACK[(int)t243];
/* Para saber donde iniciar a imprimir luego del proceso */
t238 = H;
/* Print Complex P.1 */
t245 = t237  ;
L118:
t246 = HEAP[(int)t245 ];
if(t246 == (char)123) goto L121;
HEAP[(int)H] = t246;
H = H + 1;
t245 = t245 + 1;
goto L118;
/* Print Complex P.2 */
L121:
t245 = t245 + 1;
L119:
t246 = HEAP[(int)t245 ];
if(t246 == (char)125) goto L122;
t245 = t245 + 1;
goto L119;
/* Print Complex P.3 */
L122:
t245 = t245 + 1;
/* Num to String */
t247 = t244;
/* Por si es Negativo  */
if(t247 >= 0) goto L124;
t247 = t247 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L124:
t248 = H;
t249 = t247  ;
L125:
t250 = t249 / 10;
t251 = (int)t250;
if(t251 == 0) goto L126;
t252 = (int)t249%10;
t249 = t251;
HEAP[(int)H] = (int)t252 +48;
H = H + 1;
goto L125;
L126:
HEAP[(int)H] = (int)t249+48;
H = H + 1;
/* sort_revers */
t253 = t248;
t254 = H-1;
L127:
if(t253 >= t254) goto L128;
t255 = HEAP[(int)t254 ];
t256 = HEAP[(int)t253 ];
HEAP[(int)t253] = t255;
HEAP[(int)t254] = t256;
t253 = t253 + 1;
t254 = t254 - 1;
goto L127;
L128:
/* Print Complex P.4 */
L120:
t246 = HEAP[(int)t245 ];
if(t246 == -1) goto L123;
HEAP[(int)H] = t246;
H = H + 1;
t245 = t245 + 1;
goto L120;
/* Salida print Complex */
L123:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t258 = t238  ;
L129:
t259 = HEAP[(int)t258 ];
if(t259 != -1) goto L130;
goto L131;
L130:
printf("%c",(char)t259);
t258 = t258 + 1;
goto L129;
L131:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t260 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desapilar */
/* Puntero a nuevo enviroment */
t262 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t263 = 0;
P = P - t263;
t264 = P + 1;
P = P + t263;
t265 = t262 + 1;
STACK[(int)t265] = (int)t264;
P = P + 4;
desapilar();
P = P - 4;
/* Valor de return */
t266 = P + 4;
t267 = STACK[(int)t266];
/* Para saber donde iniciar a imprimir luego del proceso */
t261 = H;
/* Print Complex P.1 */
t268 = t260  ;
L134:
t269 = HEAP[(int)t268 ];
if(t269 == (char)123) goto L137;
HEAP[(int)H] = t269;
H = H + 1;
t268 = t268 + 1;
goto L134;
/* Print Complex P.2 */
L137:
t268 = t268 + 1;
L135:
t269 = HEAP[(int)t268 ];
if(t269 == (char)125) goto L138;
t268 = t268 + 1;
goto L135;
/* Print Complex P.3 */
L138:
t268 = t268 + 1;
/* Num to String */
t270 = t267;
/* Por si es Negativo  */
if(t270 >= 0) goto L140;
t270 = t270 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L140:
t271 = H;
t272 = t270  ;
L141:
t273 = t272 / 10;
t274 = (int)t273;
if(t274 == 0) goto L142;
t275 = (int)t272%10;
t272 = t274;
HEAP[(int)H] = (int)t275 +48;
H = H + 1;
goto L141;
L142:
HEAP[(int)H] = (int)t272+48;
H = H + 1;
/* sort_revers */
t276 = t271;
t277 = H-1;
L143:
if(t276 >= t277) goto L144;
t278 = HEAP[(int)t277 ];
t279 = HEAP[(int)t276 ];
HEAP[(int)t276] = t278;
HEAP[(int)t277] = t279;
t276 = t276 + 1;
t277 = t277 - 1;
goto L143;
L144:
/* Print Complex P.4 */
L136:
t269 = HEAP[(int)t268 ];
if(t269 == -1) goto L139;
HEAP[(int)H] = t269;
H = H + 1;
t268 = t268 + 1;
goto L136;
/* Salida print Complex */
L139:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t281 = t261  ;
L145:
t282 = HEAP[(int)t281 ];
if(t282 != -1) goto L146;
goto L147;
L146:
printf("%c",(char)t282);
t281 = t281 + 1;
goto L145;
L147:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t283 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desapilar */
/* Puntero a nuevo enviroment */
t285 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t286 = 0;
P = P - t286;
t287 = P + 1;
P = P + t286;
t288 = t285 + 1;
STACK[(int)t288] = (int)t287;
P = P + 4;
desapilar();
P = P - 4;
/* Valor de return */
t289 = P + 4;
t290 = STACK[(int)t289];
/* Para saber donde iniciar a imprimir luego del proceso */
t284 = H;
/* Print Complex P.1 */
t291 = t283  ;
L150:
t292 = HEAP[(int)t291 ];
if(t292 == (char)123) goto L153;
HEAP[(int)H] = t292;
H = H + 1;
t291 = t291 + 1;
goto L150;
/* Print Complex P.2 */
L153:
t291 = t291 + 1;
L151:
t292 = HEAP[(int)t291 ];
if(t292 == (char)125) goto L154;
t291 = t291 + 1;
goto L151;
/* Print Complex P.3 */
L154:
t291 = t291 + 1;
/* Num to String */
t293 = t290;
/* Por si es Negativo  */
if(t293 >= 0) goto L156;
t293 = t293 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L156:
t294 = H;
t295 = t293  ;
L157:
t296 = t295 / 10;
t297 = (int)t296;
if(t297 == 0) goto L158;
t298 = (int)t295%10;
t295 = t297;
HEAP[(int)H] = (int)t298 +48;
H = H + 1;
goto L157;
L158:
HEAP[(int)H] = (int)t295+48;
H = H + 1;
/* sort_revers */
t299 = t294;
t300 = H-1;
L159:
if(t299 >= t300) goto L160;
t301 = HEAP[(int)t300 ];
t302 = HEAP[(int)t299 ];
HEAP[(int)t299] = t301;
HEAP[(int)t300] = t302;
t299 = t299 + 1;
t300 = t300 - 1;
goto L159;
L160:
/* Print Complex P.4 */
L152:
t292 = HEAP[(int)t291 ];
if(t292 == -1) goto L155;
HEAP[(int)H] = t292;
H = H + 1;
t291 = t291 + 1;
goto L152;
/* Salida print Complex */
L155:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t304 = t284  ;
L161:
t305 = HEAP[(int)t304 ];
if(t305 != -1) goto L162;
goto L163;
L162:
printf("%c",(char)t305);
t304 = t304 + 1;
goto L161;
L163:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t306 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desapilar */
/* Puntero a nuevo enviroment */
t308 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t309 = 0;
P = P - t309;
t310 = P + 1;
P = P + t309;
t311 = t308 + 1;
STACK[(int)t311] = (int)t310;
P = P + 4;
desapilar();
P = P - 4;
/* Valor de return */
t312 = P + 4;
t313 = STACK[(int)t312];
/* Para saber donde iniciar a imprimir luego del proceso */
t307 = H;
/* Print Complex P.1 */
t314 = t306  ;
L166:
t315 = HEAP[(int)t314 ];
if(t315 == (char)123) goto L169;
HEAP[(int)H] = t315;
H = H + 1;
t314 = t314 + 1;
goto L166;
/* Print Complex P.2 */
L169:
t314 = t314 + 1;
L167:
t315 = HEAP[(int)t314 ];
if(t315 == (char)125) goto L170;
t314 = t314 + 1;
goto L167;
/* Print Complex P.3 */
L170:
t314 = t314 + 1;
/* Num to String */
t316 = t313;
/* Por si es Negativo  */
if(t316 >= 0) goto L172;
t316 = t316 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L172:
t317 = H;
t318 = t316  ;
L173:
t319 = t318 / 10;
t320 = (int)t319;
if(t320 == 0) goto L174;
t321 = (int)t318%10;
t318 = t320;
HEAP[(int)H] = (int)t321 +48;
H = H + 1;
goto L173;
L174:
HEAP[(int)H] = (int)t318+48;
H = H + 1;
/* sort_revers */
t322 = t317;
t323 = H-1;
L175:
if(t322 >= t323) goto L176;
t324 = HEAP[(int)t323 ];
t325 = HEAP[(int)t322 ];
HEAP[(int)t322] = t324;
HEAP[(int)t323] = t325;
t322 = t322 + 1;
t323 = t323 - 1;
goto L175;
L176:
/* Print Complex P.4 */
L168:
t315 = HEAP[(int)t314 ];
if(t315 == -1) goto L171;
HEAP[(int)H] = t315;
H = H + 1;
t314 = t314 + 1;
goto L168;
/* Salida print Complex */
L171:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t327 = t307  ;
L177:
t328 = HEAP[(int)t327 ];
if(t328 != -1) goto L178;
goto L179;
L178:
printf("%c",(char)t328);
t327 = t327 + 1;
goto L177;
L179:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t329 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desapilar */
/* Puntero a nuevo enviroment */
t331 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t332 = 0;
P = P - t332;
t333 = P + 1;
P = P + t332;
t334 = t331 + 1;
STACK[(int)t334] = (int)t333;
P = P + 4;
desapilar();
P = P - 4;
/* Valor de return */
t335 = P + 4;
t336 = STACK[(int)t335];
/* Para saber donde iniciar a imprimir luego del proceso */
t330 = H;
/* Print Complex P.1 */
t337 = t329  ;
L182:
t338 = HEAP[(int)t337 ];
if(t338 == (char)123) goto L185;
HEAP[(int)H] = t338;
H = H + 1;
t337 = t337 + 1;
goto L182;
/* Print Complex P.2 */
L185:
t337 = t337 + 1;
L183:
t338 = HEAP[(int)t337 ];
if(t338 == (char)125) goto L186;
t337 = t337 + 1;
goto L183;
/* Print Complex P.3 */
L186:
t337 = t337 + 1;
/* Num to String */
t339 = t336;
/* Por si es Negativo  */
if(t339 >= 0) goto L188;
t339 = t339 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L188:
t340 = H;
t341 = t339  ;
L189:
t342 = t341 / 10;
t343 = (int)t342;
if(t343 == 0) goto L190;
t344 = (int)t341%10;
t341 = t343;
HEAP[(int)H] = (int)t344 +48;
H = H + 1;
goto L189;
L190:
HEAP[(int)H] = (int)t341+48;
H = H + 1;
/* sort_revers */
t345 = t340;
t346 = H-1;
L191:
if(t345 >= t346) goto L192;
t347 = HEAP[(int)t346 ];
t348 = HEAP[(int)t345 ];
HEAP[(int)t345] = t347;
HEAP[(int)t346] = t348;
t345 = t345 + 1;
t346 = t346 - 1;
goto L191;
L192:
/* Print Complex P.4 */
L184:
t338 = HEAP[(int)t337 ];
if(t338 == -1) goto L187;
HEAP[(int)H] = t338;
H = H + 1;
t337 = t337 + 1;
goto L184;
/* Salida print Complex */
L187:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t350 = t330  ;
L193:
t351 = HEAP[(int)t350 ];
if(t351 != -1) goto L194;
goto L195;
L194:
printf("%c",(char)t351);
t350 = t350 + 1;
goto L193;
L195:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t352 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desapilar */
/* Puntero a nuevo enviroment */
t354 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: pila */
t355 = 0;
P = P - t355;
t356 = P + 1;
P = P + t355;
t357 = t354 + 1;
STACK[(int)t357] = (int)t356;
P = P + 4;
desapilar();
P = P - 4;
/* Valor de return */
t358 = P + 4;
t359 = STACK[(int)t358];
/* Para saber donde iniciar a imprimir luego del proceso */
t353 = H;
/* Print Complex P.1 */
t360 = t352  ;
L198:
t361 = HEAP[(int)t360 ];
if(t361 == (char)123) goto L201;
HEAP[(int)H] = t361;
H = H + 1;
t360 = t360 + 1;
goto L198;
/* Print Complex P.2 */
L201:
t360 = t360 + 1;
L199:
t361 = HEAP[(int)t360 ];
if(t361 == (char)125) goto L202;
t360 = t360 + 1;
goto L199;
/* Print Complex P.3 */
L202:
t360 = t360 + 1;
/* Num to String */
t362 = t359;
/* Por si es Negativo  */
if(t362 >= 0) goto L204;
t362 = t362 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L204:
t363 = H;
t364 = t362  ;
L205:
t365 = t364 / 10;
t366 = (int)t365;
if(t366 == 0) goto L206;
t367 = (int)t364%10;
t364 = t366;
HEAP[(int)H] = (int)t367 +48;
H = H + 1;
goto L205;
L206:
HEAP[(int)H] = (int)t364+48;
H = H + 1;
/* sort_revers */
t368 = t363;
t369 = H-1;
L207:
if(t368 >= t369) goto L208;
t370 = HEAP[(int)t369 ];
t371 = HEAP[(int)t368 ];
HEAP[(int)t368] = t370;
HEAP[(int)t369] = t371;
t368 = t368 + 1;
t369 = t369 - 1;
goto L207;
L208:
/* Print Complex P.4 */
L200:
t361 = HEAP[(int)t360 ];
if(t361 == -1) goto L203;
HEAP[(int)H] = t361;
H = H + 1;
t360 = t360 + 1;
goto L200;
/* Salida print Complex */
L203:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t373 = t353  ;
L209:
t374 = HEAP[(int)t373 ];
if(t374 != -1) goto L210;
goto L211;
L210:
printf("%c",(char)t374);
t373 = t373 + 1;
goto L209;
L211:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t375 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* ID EXPRESION: pila */
t377 = 0;
P = P - t377;
t379 = P + 1;
P = P + t377;
t378 = STACK[(int)t379];
/* Para saber donde iniciar a imprimir luego del proceso */
t376 = H;
/* Print Complex P.1 */
t380 = t375  ;
L212:
t381 = HEAP[(int)t380 ];
if(t381 == (char)123) goto L215;
HEAP[(int)H] = t381;
H = H + 1;
t380 = t380 + 1;
goto L212;
/* Print Complex P.2 */
L215:
t380 = t380 + 1;
L213:
t381 = HEAP[(int)t380 ];
if(t381 == (char)125) goto L216;
t380 = t380 + 1;
goto L213;
/* Print Complex P.3 */
L216:
t380 = t380 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof 1 */
t386 = 0;
t382 = t378;
/* Tamanio */
t385 = HEAP[(int)t382 ];
t382 = t382 + 1;
t382 = t382 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L218:
if(t386 >= t385) goto L219;
t384 = t382 + t386;
t383 = HEAP[(int)t384 ];
/* Num to String */
t388 = t383;
/* Por si es Negativo  */
if(t388 >= 0) goto L220;
t388 = t388 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L220:
t389 = H;
t390 = t388  ;
L221:
t391 = t390 / 10;
t392 = (int)t391;
if(t392 == 0) goto L222;
t393 = (int)t390%10;
t390 = t392;
HEAP[(int)H] = (int)t393 +48;
H = H + 1;
goto L221;
L222:
HEAP[(int)H] = (int)t390+48;
H = H + 1;
/* sort_revers */
t394 = t389;
t395 = H-1;
L223:
if(t394 >= t395) goto L224;
t396 = HEAP[(int)t395 ];
t397 = HEAP[(int)t394 ];
HEAP[(int)t394] = t396;
HEAP[(int)t395] = t397;
t394 = t394 + 1;
t395 = t395 - 1;
goto L223;
L224:
t386 = t386 + 1;
/* Para evitar poner una comma extra */
if(t386 >= t385) goto t387;
HEAP[(int)H] = 44;
H = H + 1;
t387:
goto L218;
L219:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L214:
t381 = HEAP[(int)t380 ];
if(t381 == -1) goto L217;
HEAP[(int)H] = t381;
H = H + 1;
t380 = t380 + 1;
goto L214;
/* Salida print Complex */
L217:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t399 = t376  ;
L225:
t400 = HEAP[(int)t399 ];
if(t400 != -1) goto L226;
goto L227;
L226:
printf("%c",(char)t400);
t399 = t399 + 1;
goto L225;
L227:
printf("%c",10);
/* Primitivo tipo STR: "Capacidad de pila" */
t401 = H  ;
HEAP[(int)H] = 67;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 112;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 99;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 112;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Print de un String o CHAR */
t402 = t401  ;
L228:
t403 = HEAP[(int)t402 ];
if(t403 != -1) goto L229;
goto L230;
L229:
printf("%c",(char)t403);
t402 = t402 + 1;
goto L228;
L230:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t404 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Capacity vec: pila */
t406 = 0;
P = P - t406;
t408 = P + 1;
P = P + t406;
t409 = STACK[(int)t408];
t409 = t409 + 1;
t407 = HEAP[(int)t409 ];
/* Para saber donde iniciar a imprimir luego del proceso */
t405 = H;
/* Print Complex P.1 */
t410 = t404  ;
L231:
t411 = HEAP[(int)t410 ];
if(t411 == (char)123) goto L234;
HEAP[(int)H] = t411;
H = H + 1;
t410 = t410 + 1;
goto L231;
/* Print Complex P.2 */
L234:
t410 = t410 + 1;
L232:
t411 = HEAP[(int)t410 ];
if(t411 == (char)125) goto L235;
t410 = t410 + 1;
goto L232;
/* Print Complex P.3 */
L235:
t410 = t410 + 1;
/* Num to String */
t412 = t407;
/* Por si es Negativo  */
if(t412 >= 0) goto L237;
t412 = t412 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L237:
t413 = H;
t414 = t412  ;
L238:
t415 = t414 / 10;
t416 = (int)t415;
if(t416 == 0) goto L239;
t417 = (int)t414%10;
t414 = t416;
HEAP[(int)H] = (int)t417 +48;
H = H + 1;
goto L238;
L239:
HEAP[(int)H] = (int)t414+48;
H = H + 1;
/* sort_revers */
t418 = t413;
t419 = H-1;
L240:
if(t418 >= t419) goto L241;
t420 = HEAP[(int)t419 ];
t421 = HEAP[(int)t418 ];
HEAP[(int)t418] = t420;
HEAP[(int)t419] = t421;
t418 = t418 + 1;
t419 = t419 - 1;
goto L240;
L241:
/* Print Complex P.4 */
L233:
t411 = HEAP[(int)t410 ];
if(t411 == -1) goto L236;
HEAP[(int)H] = t411;
H = H + 1;
t410 = t410 + 1;
goto L233;
/* Salida print Complex */
L236:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t423 = t405  ;
L242:
t424 = HEAP[(int)t423 ];
if(t424 != -1) goto L243;
goto L244;
L243:
printf("%c",(char)t424);
t423 = t423 + 1;
goto L242;
L244:
printf("%c",10);
/* Primitivo tipo STR: "" */
t425 = H  ;
HEAP[(int)H] = -1;
H = H + 1;
/* Print de un String o CHAR */
t426 = t425  ;
L245:
t427 = HEAP[(int)t426 ];
if(t427 != -1) goto L246;
goto L247;
L246:
printf("%c",(char)t427);
t426 = t426 + 1;
goto L245;
L247:
printf("%c",10);
/* Llamada a funcion: encolar */
/* Puntero a nuevo enviroment */
t428 = P + 4;
/* Declaracion var: capacidad */
/* ID EXPRESION: capacidad */
t429 = 0;
P = P - t429;
t431 = P + 0;
P = P + t429;
t430 = STACK[(int)t431];
/* Ingreso a la Pila */
t432 = t428 + 1;
STACK[(int)t432] = t430;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t433 = 0;
P = P - t433;
t434 = P + 2;
P = P + t433;
t435 = t428 + 2;
STACK[(int)t435] = (int)t434;
/* Declaracion var: value */
/* Ingreso a la Pila */
t436 = t428 + 3;
STACK[(int)t436] = 800;
P = P + 4;
encolar();
P = P - 4;
/* Valor de return */
t463 = P + 4;
t464 = STACK[(int)t463];
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t465 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* ID EXPRESION: cola */
t467 = 0;
P = P - t467;
t469 = P + 2;
P = P + t467;
t468 = STACK[(int)t469];
/* Para saber donde iniciar a imprimir luego del proceso */
t466 = H;
/* Print Complex P.1 */
t470 = t465  ;
L264:
t471 = HEAP[(int)t470 ];
if(t471 == (char)123) goto L267;
HEAP[(int)H] = t471;
H = H + 1;
t470 = t470 + 1;
goto L264;
/* Print Complex P.2 */
L267:
t470 = t470 + 1;
L265:
t471 = HEAP[(int)t470 ];
if(t471 == (char)125) goto L268;
t470 = t470 + 1;
goto L265;
/* Print Complex P.3 */
L268:
t470 = t470 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof 1 */
t476 = 0;
t472 = t468;
/* Tamanio */
t475 = HEAP[(int)t472 ];
t472 = t472 + 1;
t472 = t472 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L270:
if(t476 >= t475) goto L271;
t474 = t472 + t476;
t473 = HEAP[(int)t474 ];
/* Num to String */
t478 = t473;
/* Por si es Negativo  */
if(t478 >= 0) goto L272;
t478 = t478 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L272:
t479 = H;
t480 = t478  ;
L273:
t481 = t480 / 10;
t482 = (int)t481;
if(t482 == 0) goto L274;
t483 = (int)t480%10;
t480 = t482;
HEAP[(int)H] = (int)t483 +48;
H = H + 1;
goto L273;
L274:
HEAP[(int)H] = (int)t480+48;
H = H + 1;
/* sort_revers */
t484 = t479;
t485 = H-1;
L275:
if(t484 >= t485) goto L276;
t486 = HEAP[(int)t485 ];
t487 = HEAP[(int)t484 ];
HEAP[(int)t484] = t486;
HEAP[(int)t485] = t487;
t484 = t484 + 1;
t485 = t485 - 1;
goto L275;
L276:
t476 = t476 + 1;
/* Para evitar poner una comma extra */
if(t476 >= t475) goto t477;
HEAP[(int)H] = 44;
H = H + 1;
t477:
goto L270;
L271:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L266:
t471 = HEAP[(int)t470 ];
if(t471 == -1) goto L269;
HEAP[(int)H] = t471;
H = H + 1;
t470 = t470 + 1;
goto L266;
/* Salida print Complex */
L269:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t489 = t466  ;
L277:
t490 = HEAP[(int)t489 ];
if(t490 != -1) goto L278;
goto L279;
L278:
printf("%c",(char)t490);
t489 = t489 + 1;
goto L277;
L279:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t491 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desencolar */
/* Puntero a nuevo enviroment */
t493 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t494 = 0;
P = P - t494;
t495 = P + 2;
P = P + t494;
t496 = t493 + 1;
STACK[(int)t496] = (int)t495;
P = P + 4;
desencolar();
P = P - 4;
/* Valor de return */
t529 = P + 4;
t530 = STACK[(int)t529];
/* Para saber donde iniciar a imprimir luego del proceso */
t492 = H;
/* Print Complex P.1 */
t531 = t491  ;
L301:
t532 = HEAP[(int)t531 ];
if(t532 == (char)123) goto L304;
HEAP[(int)H] = t532;
H = H + 1;
t531 = t531 + 1;
goto L301;
/* Print Complex P.2 */
L304:
t531 = t531 + 1;
L302:
t532 = HEAP[(int)t531 ];
if(t532 == (char)125) goto L305;
t531 = t531 + 1;
goto L302;
/* Print Complex P.3 */
L305:
t531 = t531 + 1;
/* Num to String */
t533 = t530;
/* Por si es Negativo  */
if(t533 >= 0) goto L307;
t533 = t533 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L307:
t534 = H;
t535 = t533  ;
L308:
t536 = t535 / 10;
t537 = (int)t536;
if(t537 == 0) goto L309;
t538 = (int)t535%10;
t535 = t537;
HEAP[(int)H] = (int)t538 +48;
H = H + 1;
goto L308;
L309:
HEAP[(int)H] = (int)t535+48;
H = H + 1;
/* sort_revers */
t539 = t534;
t540 = H-1;
L310:
if(t539 >= t540) goto L311;
t541 = HEAP[(int)t540 ];
t542 = HEAP[(int)t539 ];
HEAP[(int)t539] = t541;
HEAP[(int)t540] = t542;
t539 = t539 + 1;
t540 = t540 - 1;
goto L310;
L311:
/* Print Complex P.4 */
L303:
t532 = HEAP[(int)t531 ];
if(t532 == -1) goto L306;
HEAP[(int)H] = t532;
H = H + 1;
t531 = t531 + 1;
goto L303;
/* Salida print Complex */
L306:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t544 = t492  ;
L312:
t545 = HEAP[(int)t544 ];
if(t545 != -1) goto L313;
goto L314;
L313:
printf("%c",(char)t545);
t544 = t544 + 1;
goto L312;
L314:
printf("%c",10);
/* Llamada a funcion: encolar */
/* Puntero a nuevo enviroment */
t546 = P + 4;
/* Declaracion var: capacidad */
/* ID EXPRESION: capacidad */
t547 = 0;
P = P - t547;
t549 = P + 0;
P = P + t547;
t548 = STACK[(int)t549];
/* Ingreso a la Pila */
t550 = t546 + 1;
STACK[(int)t550] = t548;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t551 = 0;
P = P - t551;
t552 = P + 2;
P = P + t551;
t553 = t546 + 2;
STACK[(int)t553] = (int)t552;
/* Declaracion var: value */
/* Ingreso a la Pila */
t554 = t546 + 3;
STACK[(int)t554] = 1250;
P = P + 4;
encolar();
P = P - 4;
/* Valor de return */
t555 = P + 4;
t556 = STACK[(int)t555];
/* Llamada a funcion: encolar */
/* Puntero a nuevo enviroment */
t557 = P + 4;
/* Declaracion var: capacidad */
/* ID EXPRESION: capacidad */
t558 = 0;
P = P - t558;
t560 = P + 0;
P = P + t558;
t559 = STACK[(int)t560];
/* Ingreso a la Pila */
t561 = t557 + 1;
STACK[(int)t561] = t559;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t562 = 0;
P = P - t562;
t563 = P + 2;
P = P + t562;
t564 = t557 + 2;
STACK[(int)t564] = (int)t563;
/* Declaracion var: value */
/* Ingreso a la Pila */
t565 = t557 + 3;
STACK[(int)t565] = 2200;
P = P + 4;
encolar();
P = P - 4;
/* Valor de return */
t566 = P + 4;
t567 = STACK[(int)t566];
/* Llamada a funcion: encolar */
/* Puntero a nuevo enviroment */
t568 = P + 4;
/* Declaracion var: capacidad */
/* ID EXPRESION: capacidad */
t569 = 0;
P = P - t569;
t571 = P + 0;
P = P + t569;
t570 = STACK[(int)t571];
/* Ingreso a la Pila */
t572 = t568 + 1;
STACK[(int)t572] = t570;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t573 = 0;
P = P - t573;
t574 = P + 2;
P = P + t573;
t575 = t568 + 2;
STACK[(int)t575] = (int)t574;
/* Declaracion var: value */
/* Ingreso a la Pila */
t576 = t568 + 3;
STACK[(int)t576] = 3500;
P = P + 4;
encolar();
P = P - 4;
/* Valor de return */
t577 = P + 4;
t578 = STACK[(int)t577];
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t579 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desencolar */
/* Puntero a nuevo enviroment */
t581 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t582 = 0;
P = P - t582;
t583 = P + 2;
P = P + t582;
t584 = t581 + 1;
STACK[(int)t584] = (int)t583;
P = P + 4;
desencolar();
P = P - 4;
/* Valor de return */
t585 = P + 4;
t586 = STACK[(int)t585];
/* Para saber donde iniciar a imprimir luego del proceso */
t580 = H;
/* Print Complex P.1 */
t587 = t579  ;
L323:
t588 = HEAP[(int)t587 ];
if(t588 == (char)123) goto L326;
HEAP[(int)H] = t588;
H = H + 1;
t587 = t587 + 1;
goto L323;
/* Print Complex P.2 */
L326:
t587 = t587 + 1;
L324:
t588 = HEAP[(int)t587 ];
if(t588 == (char)125) goto L327;
t587 = t587 + 1;
goto L324;
/* Print Complex P.3 */
L327:
t587 = t587 + 1;
/* Num to String */
t589 = t586;
/* Por si es Negativo  */
if(t589 >= 0) goto L329;
t589 = t589 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L329:
t590 = H;
t591 = t589  ;
L330:
t592 = t591 / 10;
t593 = (int)t592;
if(t593 == 0) goto L331;
t594 = (int)t591%10;
t591 = t593;
HEAP[(int)H] = (int)t594 +48;
H = H + 1;
goto L330;
L331:
HEAP[(int)H] = (int)t591+48;
H = H + 1;
/* sort_revers */
t595 = t590;
t596 = H-1;
L332:
if(t595 >= t596) goto L333;
t597 = HEAP[(int)t596 ];
t598 = HEAP[(int)t595 ];
HEAP[(int)t595] = t597;
HEAP[(int)t596] = t598;
t595 = t595 + 1;
t596 = t596 - 1;
goto L332;
L333:
/* Print Complex P.4 */
L325:
t588 = HEAP[(int)t587 ];
if(t588 == -1) goto L328;
HEAP[(int)H] = t588;
H = H + 1;
t587 = t587 + 1;
goto L325;
/* Salida print Complex */
L328:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t600 = t580  ;
L334:
t601 = HEAP[(int)t600 ];
if(t601 != -1) goto L335;
goto L336;
L335:
printf("%c",(char)t601);
t600 = t600 + 1;
goto L334;
L336:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t602 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desencolar */
/* Puntero a nuevo enviroment */
t604 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t605 = 0;
P = P - t605;
t606 = P + 2;
P = P + t605;
t607 = t604 + 1;
STACK[(int)t607] = (int)t606;
P = P + 4;
desencolar();
P = P - 4;
/* Valor de return */
t608 = P + 4;
t609 = STACK[(int)t608];
/* Para saber donde iniciar a imprimir luego del proceso */
t603 = H;
/* Print Complex P.1 */
t610 = t602  ;
L339:
t611 = HEAP[(int)t610 ];
if(t611 == (char)123) goto L342;
HEAP[(int)H] = t611;
H = H + 1;
t610 = t610 + 1;
goto L339;
/* Print Complex P.2 */
L342:
t610 = t610 + 1;
L340:
t611 = HEAP[(int)t610 ];
if(t611 == (char)125) goto L343;
t610 = t610 + 1;
goto L340;
/* Print Complex P.3 */
L343:
t610 = t610 + 1;
/* Num to String */
t612 = t609;
/* Por si es Negativo  */
if(t612 >= 0) goto L345;
t612 = t612 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L345:
t613 = H;
t614 = t612  ;
L346:
t615 = t614 / 10;
t616 = (int)t615;
if(t616 == 0) goto L347;
t617 = (int)t614%10;
t614 = t616;
HEAP[(int)H] = (int)t617 +48;
H = H + 1;
goto L346;
L347:
HEAP[(int)H] = (int)t614+48;
H = H + 1;
/* sort_revers */
t618 = t613;
t619 = H-1;
L348:
if(t618 >= t619) goto L349;
t620 = HEAP[(int)t619 ];
t621 = HEAP[(int)t618 ];
HEAP[(int)t618] = t620;
HEAP[(int)t619] = t621;
t618 = t618 + 1;
t619 = t619 - 1;
goto L348;
L349:
/* Print Complex P.4 */
L341:
t611 = HEAP[(int)t610 ];
if(t611 == -1) goto L344;
HEAP[(int)H] = t611;
H = H + 1;
t610 = t610 + 1;
goto L341;
/* Salida print Complex */
L344:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t623 = t603  ;
L350:
t624 = HEAP[(int)t623 ];
if(t624 != -1) goto L351;
goto L352;
L351:
printf("%c",(char)t624);
t623 = t623 + 1;
goto L350;
L352:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t625 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desencolar */
/* Puntero a nuevo enviroment */
t627 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t628 = 0;
P = P - t628;
t629 = P + 2;
P = P + t628;
t630 = t627 + 1;
STACK[(int)t630] = (int)t629;
P = P + 4;
desencolar();
P = P - 4;
/* Valor de return */
t631 = P + 4;
t632 = STACK[(int)t631];
/* Para saber donde iniciar a imprimir luego del proceso */
t626 = H;
/* Print Complex P.1 */
t633 = t625  ;
L355:
t634 = HEAP[(int)t633 ];
if(t634 == (char)123) goto L358;
HEAP[(int)H] = t634;
H = H + 1;
t633 = t633 + 1;
goto L355;
/* Print Complex P.2 */
L358:
t633 = t633 + 1;
L356:
t634 = HEAP[(int)t633 ];
if(t634 == (char)125) goto L359;
t633 = t633 + 1;
goto L356;
/* Print Complex P.3 */
L359:
t633 = t633 + 1;
/* Num to String */
t635 = t632;
/* Por si es Negativo  */
if(t635 >= 0) goto L361;
t635 = t635 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L361:
t636 = H;
t637 = t635  ;
L362:
t638 = t637 / 10;
t639 = (int)t638;
if(t639 == 0) goto L363;
t640 = (int)t637%10;
t637 = t639;
HEAP[(int)H] = (int)t640 +48;
H = H + 1;
goto L362;
L363:
HEAP[(int)H] = (int)t637+48;
H = H + 1;
/* sort_revers */
t641 = t636;
t642 = H-1;
L364:
if(t641 >= t642) goto L365;
t643 = HEAP[(int)t642 ];
t644 = HEAP[(int)t641 ];
HEAP[(int)t641] = t643;
HEAP[(int)t642] = t644;
t641 = t641 + 1;
t642 = t642 - 1;
goto L364;
L365:
/* Print Complex P.4 */
L357:
t634 = HEAP[(int)t633 ];
if(t634 == -1) goto L360;
HEAP[(int)H] = t634;
H = H + 1;
t633 = t633 + 1;
goto L357;
/* Salida print Complex */
L360:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t646 = t626  ;
L366:
t647 = HEAP[(int)t646 ];
if(t647 != -1) goto L367;
goto L368;
L367:
printf("%c",(char)t647);
t646 = t646 + 1;
goto L366;
L368:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t648 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desencolar */
/* Puntero a nuevo enviroment */
t650 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t651 = 0;
P = P - t651;
t652 = P + 2;
P = P + t651;
t653 = t650 + 1;
STACK[(int)t653] = (int)t652;
P = P + 4;
desencolar();
P = P - 4;
/* Valor de return */
t654 = P + 4;
t655 = STACK[(int)t654];
/* Para saber donde iniciar a imprimir luego del proceso */
t649 = H;
/* Print Complex P.1 */
t656 = t648  ;
L371:
t657 = HEAP[(int)t656 ];
if(t657 == (char)123) goto L374;
HEAP[(int)H] = t657;
H = H + 1;
t656 = t656 + 1;
goto L371;
/* Print Complex P.2 */
L374:
t656 = t656 + 1;
L372:
t657 = HEAP[(int)t656 ];
if(t657 == (char)125) goto L375;
t656 = t656 + 1;
goto L372;
/* Print Complex P.3 */
L375:
t656 = t656 + 1;
/* Num to String */
t658 = t655;
/* Por si es Negativo  */
if(t658 >= 0) goto L377;
t658 = t658 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L377:
t659 = H;
t660 = t658  ;
L378:
t661 = t660 / 10;
t662 = (int)t661;
if(t662 == 0) goto L379;
t663 = (int)t660%10;
t660 = t662;
HEAP[(int)H] = (int)t663 +48;
H = H + 1;
goto L378;
L379:
HEAP[(int)H] = (int)t660+48;
H = H + 1;
/* sort_revers */
t664 = t659;
t665 = H-1;
L380:
if(t664 >= t665) goto L381;
t666 = HEAP[(int)t665 ];
t667 = HEAP[(int)t664 ];
HEAP[(int)t664] = t666;
HEAP[(int)t665] = t667;
t664 = t664 + 1;
t665 = t665 - 1;
goto L380;
L381:
/* Print Complex P.4 */
L373:
t657 = HEAP[(int)t656 ];
if(t657 == -1) goto L376;
HEAP[(int)H] = t657;
H = H + 1;
t656 = t656 + 1;
goto L373;
/* Salida print Complex */
L376:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t669 = t649  ;
L382:
t670 = HEAP[(int)t669 ];
if(t670 != -1) goto L383;
goto L384;
L383:
printf("%c",(char)t670);
t669 = t669 + 1;
goto L382;
L384:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t671 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desencolar */
/* Puntero a nuevo enviroment */
t673 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t674 = 0;
P = P - t674;
t675 = P + 2;
P = P + t674;
t676 = t673 + 1;
STACK[(int)t676] = (int)t675;
P = P + 4;
desencolar();
P = P - 4;
/* Valor de return */
t677 = P + 4;
t678 = STACK[(int)t677];
/* Para saber donde iniciar a imprimir luego del proceso */
t672 = H;
/* Print Complex P.1 */
t679 = t671  ;
L387:
t680 = HEAP[(int)t679 ];
if(t680 == (char)123) goto L390;
HEAP[(int)H] = t680;
H = H + 1;
t679 = t679 + 1;
goto L387;
/* Print Complex P.2 */
L390:
t679 = t679 + 1;
L388:
t680 = HEAP[(int)t679 ];
if(t680 == (char)125) goto L391;
t679 = t679 + 1;
goto L388;
/* Print Complex P.3 */
L391:
t679 = t679 + 1;
/* Num to String */
t681 = t678;
/* Por si es Negativo  */
if(t681 >= 0) goto L393;
t681 = t681 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L393:
t682 = H;
t683 = t681  ;
L394:
t684 = t683 / 10;
t685 = (int)t684;
if(t685 == 0) goto L395;
t686 = (int)t683%10;
t683 = t685;
HEAP[(int)H] = (int)t686 +48;
H = H + 1;
goto L394;
L395:
HEAP[(int)H] = (int)t683+48;
H = H + 1;
/* sort_revers */
t687 = t682;
t688 = H-1;
L396:
if(t687 >= t688) goto L397;
t689 = HEAP[(int)t688 ];
t690 = HEAP[(int)t687 ];
HEAP[(int)t687] = t689;
HEAP[(int)t688] = t690;
t687 = t687 + 1;
t688 = t688 - 1;
goto L396;
L397:
/* Print Complex P.4 */
L389:
t680 = HEAP[(int)t679 ];
if(t680 == -1) goto L392;
HEAP[(int)H] = t680;
H = H + 1;
t679 = t679 + 1;
goto L389;
/* Salida print Complex */
L392:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t692 = t672  ;
L398:
t693 = HEAP[(int)t692 ];
if(t693 != -1) goto L399;
goto L400;
L399:
printf("%c",(char)t693);
t692 = t692 + 1;
goto L398;
L400:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t694 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desencolar */
/* Puntero a nuevo enviroment */
t696 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t697 = 0;
P = P - t697;
t698 = P + 2;
P = P + t697;
t699 = t696 + 1;
STACK[(int)t699] = (int)t698;
P = P + 4;
desencolar();
P = P - 4;
/* Valor de return */
t700 = P + 4;
t701 = STACK[(int)t700];
/* Para saber donde iniciar a imprimir luego del proceso */
t695 = H;
/* Print Complex P.1 */
t702 = t694  ;
L403:
t703 = HEAP[(int)t702 ];
if(t703 == (char)123) goto L406;
HEAP[(int)H] = t703;
H = H + 1;
t702 = t702 + 1;
goto L403;
/* Print Complex P.2 */
L406:
t702 = t702 + 1;
L404:
t703 = HEAP[(int)t702 ];
if(t703 == (char)125) goto L407;
t702 = t702 + 1;
goto L404;
/* Print Complex P.3 */
L407:
t702 = t702 + 1;
/* Num to String */
t704 = t701;
/* Por si es Negativo  */
if(t704 >= 0) goto L409;
t704 = t704 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L409:
t705 = H;
t706 = t704  ;
L410:
t707 = t706 / 10;
t708 = (int)t707;
if(t708 == 0) goto L411;
t709 = (int)t706%10;
t706 = t708;
HEAP[(int)H] = (int)t709 +48;
H = H + 1;
goto L410;
L411:
HEAP[(int)H] = (int)t706+48;
H = H + 1;
/* sort_revers */
t710 = t705;
t711 = H-1;
L412:
if(t710 >= t711) goto L413;
t712 = HEAP[(int)t711 ];
t713 = HEAP[(int)t710 ];
HEAP[(int)t710] = t712;
HEAP[(int)t711] = t713;
t710 = t710 + 1;
t711 = t711 - 1;
goto L412;
L413:
/* Print Complex P.4 */
L405:
t703 = HEAP[(int)t702 ];
if(t703 == -1) goto L408;
HEAP[(int)H] = t703;
H = H + 1;
t702 = t702 + 1;
goto L405;
/* Salida print Complex */
L408:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t715 = t695  ;
L414:
t716 = HEAP[(int)t715 ];
if(t716 != -1) goto L415;
goto L416;
L415:
printf("%c",(char)t716);
t715 = t715 + 1;
goto L414;
L416:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t717 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desencolar */
/* Puntero a nuevo enviroment */
t719 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t720 = 0;
P = P - t720;
t721 = P + 2;
P = P + t720;
t722 = t719 + 1;
STACK[(int)t722] = (int)t721;
P = P + 4;
desencolar();
P = P - 4;
/* Valor de return */
t723 = P + 4;
t724 = STACK[(int)t723];
/* Para saber donde iniciar a imprimir luego del proceso */
t718 = H;
/* Print Complex P.1 */
t725 = t717  ;
L419:
t726 = HEAP[(int)t725 ];
if(t726 == (char)123) goto L422;
HEAP[(int)H] = t726;
H = H + 1;
t725 = t725 + 1;
goto L419;
/* Print Complex P.2 */
L422:
t725 = t725 + 1;
L420:
t726 = HEAP[(int)t725 ];
if(t726 == (char)125) goto L423;
t725 = t725 + 1;
goto L420;
/* Print Complex P.3 */
L423:
t725 = t725 + 1;
/* Num to String */
t727 = t724;
/* Por si es Negativo  */
if(t727 >= 0) goto L425;
t727 = t727 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L425:
t728 = H;
t729 = t727  ;
L426:
t730 = t729 / 10;
t731 = (int)t730;
if(t731 == 0) goto L427;
t732 = (int)t729%10;
t729 = t731;
HEAP[(int)H] = (int)t732 +48;
H = H + 1;
goto L426;
L427:
HEAP[(int)H] = (int)t729+48;
H = H + 1;
/* sort_revers */
t733 = t728;
t734 = H-1;
L428:
if(t733 >= t734) goto L429;
t735 = HEAP[(int)t734 ];
t736 = HEAP[(int)t733 ];
HEAP[(int)t733] = t735;
HEAP[(int)t734] = t736;
t733 = t733 + 1;
t734 = t734 - 1;
goto L428;
L429:
/* Print Complex P.4 */
L421:
t726 = HEAP[(int)t725 ];
if(t726 == -1) goto L424;
HEAP[(int)H] = t726;
H = H + 1;
t725 = t725 + 1;
goto L421;
/* Salida print Complex */
L424:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t738 = t718  ;
L430:
t739 = HEAP[(int)t738 ];
if(t739 != -1) goto L431;
goto L432;
L431:
printf("%c",(char)t739);
t738 = t738 + 1;
goto L430;
L432:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t740 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Llamada a funcion: desencolar */
/* Puntero a nuevo enviroment */
t742 = P + 4;
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* ID EXPRESION: cola */
t743 = 0;
P = P - t743;
t744 = P + 2;
P = P + t743;
t745 = t742 + 1;
STACK[(int)t745] = (int)t744;
P = P + 4;
desencolar();
P = P - 4;
/* Valor de return */
t746 = P + 4;
t747 = STACK[(int)t746];
/* Para saber donde iniciar a imprimir luego del proceso */
t741 = H;
/* Print Complex P.1 */
t748 = t740  ;
L435:
t749 = HEAP[(int)t748 ];
if(t749 == (char)123) goto L438;
HEAP[(int)H] = t749;
H = H + 1;
t748 = t748 + 1;
goto L435;
/* Print Complex P.2 */
L438:
t748 = t748 + 1;
L436:
t749 = HEAP[(int)t748 ];
if(t749 == (char)125) goto L439;
t748 = t748 + 1;
goto L436;
/* Print Complex P.3 */
L439:
t748 = t748 + 1;
/* Num to String */
t750 = t747;
/* Por si es Negativo  */
if(t750 >= 0) goto L441;
t750 = t750 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L441:
t751 = H;
t752 = t750  ;
L442:
t753 = t752 / 10;
t754 = (int)t753;
if(t754 == 0) goto L443;
t755 = (int)t752%10;
t752 = t754;
HEAP[(int)H] = (int)t755 +48;
H = H + 1;
goto L442;
L443:
HEAP[(int)H] = (int)t752+48;
H = H + 1;
/* sort_revers */
t756 = t751;
t757 = H-1;
L444:
if(t756 >= t757) goto L445;
t758 = HEAP[(int)t757 ];
t759 = HEAP[(int)t756 ];
HEAP[(int)t756] = t758;
HEAP[(int)t757] = t759;
t756 = t756 + 1;
t757 = t757 - 1;
goto L444;
L445:
/* Print Complex P.4 */
L437:
t749 = HEAP[(int)t748 ];
if(t749 == -1) goto L440;
HEAP[(int)H] = t749;
H = H + 1;
t748 = t748 + 1;
goto L437;
/* Salida print Complex */
L440:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t761 = t741  ;
L446:
t762 = HEAP[(int)t761 ];
if(t762 != -1) goto L447;
goto L448;
L447:
printf("%c",(char)t762);
t761 = t761 + 1;
goto L446;
L448:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t763 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* ID EXPRESION: cola */
t765 = 0;
P = P - t765;
t767 = P + 2;
P = P + t765;
t766 = STACK[(int)t767];
/* Para saber donde iniciar a imprimir luego del proceso */
t764 = H;
/* Print Complex P.1 */
t768 = t763  ;
L449:
t769 = HEAP[(int)t768 ];
if(t769 == (char)123) goto L452;
HEAP[(int)H] = t769;
H = H + 1;
t768 = t768 + 1;
goto L449;
/* Print Complex P.2 */
L452:
t768 = t768 + 1;
L450:
t769 = HEAP[(int)t768 ];
if(t769 == (char)125) goto L453;
t768 = t768 + 1;
goto L450;
/* Print Complex P.3 */
L453:
t768 = t768 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof 1 */
t774 = 0;
t770 = t766;
/* Tamanio */
t773 = HEAP[(int)t770 ];
t770 = t770 + 1;
t770 = t770 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L455:
if(t774 >= t773) goto L456;
t772 = t770 + t774;
t771 = HEAP[(int)t772 ];
/* Num to String */
t776 = t771;
/* Por si es Negativo  */
if(t776 >= 0) goto L457;
t776 = t776 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L457:
t777 = H;
t778 = t776  ;
L458:
t779 = t778 / 10;
t780 = (int)t779;
if(t780 == 0) goto L459;
t781 = (int)t778%10;
t778 = t780;
HEAP[(int)H] = (int)t781 +48;
H = H + 1;
goto L458;
L459:
HEAP[(int)H] = (int)t778+48;
H = H + 1;
/* sort_revers */
t782 = t777;
t783 = H-1;
L460:
if(t782 >= t783) goto L461;
t784 = HEAP[(int)t783 ];
t785 = HEAP[(int)t782 ];
HEAP[(int)t782] = t784;
HEAP[(int)t783] = t785;
t782 = t782 + 1;
t783 = t783 - 1;
goto L460;
L461:
t774 = t774 + 1;
/* Para evitar poner una comma extra */
if(t774 >= t773) goto t775;
HEAP[(int)H] = 44;
H = H + 1;
t775:
goto L455;
L456:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L451:
t769 = HEAP[(int)t768 ];
if(t769 == -1) goto L454;
HEAP[(int)H] = t769;
H = H + 1;
t768 = t768 + 1;
goto L451;
/* Salida print Complex */
L454:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t787 = t764  ;
L462:
t788 = HEAP[(int)t787 ];
if(t788 != -1) goto L463;
goto L464;
L463:
printf("%c",(char)t788);
t787 = t787 + 1;
goto L462;
L464:
printf("%c",10);
/* Primitivo tipo STR: "Capacidad de cola" */
t789 = H  ;
HEAP[(int)H] = 67;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 112;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 99;
H = H + 1;
HEAP[(int)H] = 105;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 100;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 32;
H = H + 1;
HEAP[(int)H] = 99;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Print de un String o CHAR */
t790 = t789  ;
L465:
t791 = HEAP[(int)t790 ];
if(t791 != -1) goto L466;
goto L467;
L466:
printf("%c",(char)t791);
t790 = t790 + 1;
goto L465;
L467:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t792 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Capacity vec: cola */
t794 = 0;
P = P - t794;
t796 = P + 2;
P = P + t794;
t797 = STACK[(int)t796];
t797 = t797 + 1;
t795 = HEAP[(int)t797 ];
/* Para saber donde iniciar a imprimir luego del proceso */
t793 = H;
/* Print Complex P.1 */
t798 = t792  ;
L468:
t799 = HEAP[(int)t798 ];
if(t799 == (char)123) goto L471;
HEAP[(int)H] = t799;
H = H + 1;
t798 = t798 + 1;
goto L468;
/* Print Complex P.2 */
L471:
t798 = t798 + 1;
L469:
t799 = HEAP[(int)t798 ];
if(t799 == (char)125) goto L472;
t798 = t798 + 1;
goto L469;
/* Print Complex P.3 */
L472:
t798 = t798 + 1;
/* Num to String */
t800 = t795;
/* Por si es Negativo  */
if(t800 >= 0) goto L474;
t800 = t800 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L474:
t801 = H;
t802 = t800  ;
L475:
t803 = t802 / 10;
t804 = (int)t803;
if(t804 == 0) goto L476;
t805 = (int)t802%10;
t802 = t804;
HEAP[(int)H] = (int)t805 +48;
H = H + 1;
goto L475;
L476:
HEAP[(int)H] = (int)t802+48;
H = H + 1;
/* sort_revers */
t806 = t801;
t807 = H-1;
L477:
if(t806 >= t807) goto L478;
t808 = HEAP[(int)t807 ];
t809 = HEAP[(int)t806 ];
HEAP[(int)t806] = t808;
HEAP[(int)t807] = t809;
t806 = t806 + 1;
t807 = t807 - 1;
goto L477;
L478:
/* Print Complex P.4 */
L470:
t799 = HEAP[(int)t798 ];
if(t799 == -1) goto L473;
HEAP[(int)H] = t799;
H = H + 1;
t798 = t798 + 1;
goto L470;
/* Salida print Complex */
L473:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t811 = t793  ;
L479:
t812 = HEAP[(int)t811 ];
if(t812 != -1) goto L480;
goto L481;
L480:
printf("%c",(char)t812);
t811 = t811 + 1;
goto L479;
L481:
printf("%c",10);
/* Primitivo tipo STR: "" */
t813 = H  ;
HEAP[(int)H] = -1;
H = H + 1;
/* Print de un String o CHAR */
t814 = t813  ;
L482:
t815 = HEAP[(int)t814 ];
if(t815 != -1) goto L483;
goto L484;
L483:
printf("%c",(char)t815);
t814 = t814 + 1;
goto L482;
L484:
printf("%c",10);
/* Declaracion de Vector: lista */
/* Vector con New */
t816 = H;
/* tamanio Vector */
HEAP[(int)H] = 0;
H = H + 1;
/* Capacity Vector */
HEAP[(int)H] = 0;
H = H + 1;
/* -------------- */
t817 = P + 4;
STACK[(int)t817] = t816;
/* Push Vector lista */
t818 = 0;
/* Exp Vec! */
t819 = H;
t820 = 0;
t821 = 10;
/* Tamanio Vec! */
HEAP[(int)H] = t821;
H = H + 1;
/* --------------- */
/* Capacity del vec */
HEAP[(int)H] = t821;
H = H + 1;
/* --------------- */
t822 = 0;
L485:
if(t820 >= t821) goto L486;
HEAP[(int)H] = t822;
H = H + 1;
t820 = t820 + 1;
goto L485;
L486:
t823 = t819;
P = P - t818;
t830 = P + 4;
P = P + t818;
t824 = STACK[(int)t830];
t825 = HEAP[(int)t824 ];
t824 = t824 + 1;
t826 = HEAP[(int)t824 ];
t824 = t824 + 1;
/* Si la capacidad es 0 */
if(t826 != 0) goto L490;
t826 = 4;
L490:
/* Si el tamanio es igual o mayor a capacity */
if(t825 < t826) goto L489;
t826 = t826 * 2;
L489:
t829 = 0;
STACK[(int)t830] = H;
/* New Tamanio */
t827 = t825 + 1;
HEAP[(int)H] = t827;
H = H + 1;
/* New Capacity */
HEAP[(int)H] = t826;
H = H + 1;
L487:
if(t829 >= t825) goto L488;
t828 = HEAP[(int)t824 ];
HEAP[(int)H] = t828;
H = H + 1;
t824 = t824 + 1;
t829 = t829 + 1;
goto L487;
L488:
HEAP[(int)H] = t823;
H = H + 1;
/* Push Vector lista */
t831 = 0;
/* Exp Vec! */
t832 = H;
t833 = 0;
t834 = 10;
/* Tamanio Vec! */
HEAP[(int)H] = t834;
H = H + 1;
/* --------------- */
/* Capacity del vec */
HEAP[(int)H] = t834;
H = H + 1;
/* --------------- */
t835 = 1;
L491:
if(t833 >= t834) goto L492;
HEAP[(int)H] = t835;
H = H + 1;
t833 = t833 + 1;
goto L491;
L492:
t836 = t832;
P = P - t831;
t843 = P + 4;
P = P + t831;
t837 = STACK[(int)t843];
t838 = HEAP[(int)t837 ];
t837 = t837 + 1;
t839 = HEAP[(int)t837 ];
t837 = t837 + 1;
/* Si la capacidad es 0 */
if(t839 != 0) goto L496;
t839 = 4;
L496:
/* Si el tamanio es igual o mayor a capacity */
if(t838 < t839) goto L495;
t839 = t839 * 2;
L495:
t842 = 0;
STACK[(int)t843] = H;
/* New Tamanio */
t840 = t838 + 1;
HEAP[(int)H] = t840;
H = H + 1;
/* New Capacity */
HEAP[(int)H] = t839;
H = H + 1;
L493:
if(t842 >= t838) goto L494;
t841 = HEAP[(int)t837 ];
HEAP[(int)H] = t841;
H = H + 1;
t837 = t837 + 1;
t842 = t842 + 1;
goto L493;
L494:
HEAP[(int)H] = t836;
H = H + 1;
/* Push Vector lista */
t844 = 0;
/* Exp Vec! */
t845 = H;
t846 = 0;
t847 = 10;
/* Tamanio Vec! */
HEAP[(int)H] = t847;
H = H + 1;
/* --------------- */
/* Capacity del vec */
HEAP[(int)H] = t847;
H = H + 1;
/* --------------- */
t848 = 2;
L497:
if(t846 >= t847) goto L498;
HEAP[(int)H] = t848;
H = H + 1;
t846 = t846 + 1;
goto L497;
L498:
t849 = t845;
P = P - t844;
t856 = P + 4;
P = P + t844;
t850 = STACK[(int)t856];
t851 = HEAP[(int)t850 ];
t850 = t850 + 1;
t852 = HEAP[(int)t850 ];
t850 = t850 + 1;
/* Si la capacidad es 0 */
if(t852 != 0) goto L502;
t852 = 4;
L502:
/* Si el tamanio es igual o mayor a capacity */
if(t851 < t852) goto L501;
t852 = t852 * 2;
L501:
t855 = 0;
STACK[(int)t856] = H;
/* New Tamanio */
t853 = t851 + 1;
HEAP[(int)H] = t853;
H = H + 1;
/* New Capacity */
HEAP[(int)H] = t852;
H = H + 1;
L499:
if(t855 >= t851) goto L500;
t854 = HEAP[(int)t850 ];
HEAP[(int)H] = t854;
H = H + 1;
t850 = t850 + 1;
t855 = t855 + 1;
goto L499;
L500:
HEAP[(int)H] = t849;
H = H + 1;
/* Push Vector lista */
t857 = 0;
/* Exp Vec! */
t858 = H;
t859 = 0;
t860 = 10;
/* Tamanio Vec! */
HEAP[(int)H] = t860;
H = H + 1;
/* --------------- */
/* Capacity del vec */
HEAP[(int)H] = t860;
H = H + 1;
/* --------------- */
t861 = 3;
L503:
if(t859 >= t860) goto L504;
HEAP[(int)H] = t861;
H = H + 1;
t859 = t859 + 1;
goto L503;
L504:
t862 = t858;
P = P - t857;
t869 = P + 4;
P = P + t857;
t863 = STACK[(int)t869];
t864 = HEAP[(int)t863 ];
t863 = t863 + 1;
t865 = HEAP[(int)t863 ];
t863 = t863 + 1;
/* Si la capacidad es 0 */
if(t865 != 0) goto L508;
t865 = 4;
L508:
/* Si el tamanio es igual o mayor a capacity */
if(t864 < t865) goto L507;
t865 = t865 * 2;
L507:
t868 = 0;
STACK[(int)t869] = H;
/* New Tamanio */
t866 = t864 + 1;
HEAP[(int)H] = t866;
H = H + 1;
/* New Capacity */
HEAP[(int)H] = t865;
H = H + 1;
L505:
if(t868 >= t864) goto L506;
t867 = HEAP[(int)t863 ];
HEAP[(int)H] = t867;
H = H + 1;
t863 = t863 + 1;
t868 = t868 + 1;
goto L505;
L506:
HEAP[(int)H] = t862;
H = H + 1;
/* Push Vector lista */
t870 = 0;
/* Exp Vec! */
t871 = H;
/* Tamanio Vec! */
HEAP[(int)H] = 9;
H = H + 1;
/* --------------- */
/* Capacity del vec */
HEAP[(int)H] = 9;
H = H + 1;
/* --------------- */
HEAP[(int)H] = 75;
H = H + 1;
HEAP[(int)H] = 23;
H = H + 1;
HEAP[(int)H] = 10;
H = H + 1;
HEAP[(int)H] = 29;
H = H + 1;
HEAP[(int)H] = 30;
H = H + 1;
HEAP[(int)H] = 12;
H = H + 1;
HEAP[(int)H] = 49;
H = H + 1;
HEAP[(int)H] = 10;
H = H + 1;
HEAP[(int)H] = 93;
H = H + 1;
t872 = t871;
P = P - t870;
t879 = P + 4;
P = P + t870;
t873 = STACK[(int)t879];
t874 = HEAP[(int)t873 ];
t873 = t873 + 1;
t875 = HEAP[(int)t873 ];
t873 = t873 + 1;
/* Si la capacidad es 0 */
if(t875 != 0) goto L512;
t875 = 4;
L512:
/* Si el tamanio es igual o mayor a capacity */
if(t874 < t875) goto L511;
t875 = t875 * 2;
L511:
t878 = 0;
STACK[(int)t879] = H;
/* New Tamanio */
t876 = t874 + 1;
HEAP[(int)H] = t876;
H = H + 1;
/* New Capacity */
HEAP[(int)H] = t875;
H = H + 1;
L509:
if(t878 >= t874) goto L510;
t877 = HEAP[(int)t873 ];
HEAP[(int)H] = t877;
H = H + 1;
t873 = t873 + 1;
t878 = t878 + 1;
goto L509;
L510:
HEAP[(int)H] = t872;
H = H + 1;
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t880 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* ID EXPRESION: lista */
t882 = 0;
P = P - t882;
t884 = P + 4;
P = P + t882;
t883 = STACK[(int)t884];
/* Para saber donde iniciar a imprimir luego del proceso */
t881 = H;
/* Print Complex P.1 */
t885 = t880  ;
L513:
t886 = HEAP[(int)t885 ];
if(t886 == (char)123) goto L516;
HEAP[(int)H] = t886;
H = H + 1;
t885 = t885 + 1;
goto L513;
/* Print Complex P.2 */
L516:
t885 = t885 + 1;
L514:
t886 = HEAP[(int)t885 ];
if(t886 == (char)125) goto L517;
t885 = t885 + 1;
goto L514;
/* Print Complex P.3 */
L517:
t885 = t885 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof N */
t887 = t883;
t891 = 0;
/* Tamanio array prof N */
t890 = HEAP[(int)t887 ];
t887 = t887 + 1;
t887 = t887 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L519:
if(t891 >= t890) goto L520;
t889 = t887 + t891;
t888 = HEAP[(int)t889 ];
/* Print array prof 1 */
t897 = 0;
t893 = t888;
/* Tamanio */
t896 = HEAP[(int)t893 ];
t893 = t893 + 1;
t893 = t893 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L521:
if(t897 >= t896) goto L522;
t895 = t893 + t897;
t894 = HEAP[(int)t895 ];
/* Num to String */
t899 = t894;
/* Por si es Negativo  */
if(t899 >= 0) goto L523;
t899 = t899 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L523:
t900 = H;
t901 = t899  ;
L524:
t902 = t901 / 10;
t903 = (int)t902;
if(t903 == 0) goto L525;
t904 = (int)t901%10;
t901 = t903;
HEAP[(int)H] = (int)t904 +48;
H = H + 1;
goto L524;
L525:
HEAP[(int)H] = (int)t901+48;
H = H + 1;
/* sort_revers */
t905 = t900;
t906 = H-1;
L526:
if(t905 >= t906) goto L527;
t907 = HEAP[(int)t906 ];
t908 = HEAP[(int)t905 ];
HEAP[(int)t905] = t907;
HEAP[(int)t906] = t908;
t905 = t905 + 1;
t906 = t906 - 1;
goto L526;
L527:
t897 = t897 + 1;
/* Para evitar poner una comma extra */
if(t897 >= t896) goto t898;
HEAP[(int)H] = 44;
H = H + 1;
t898:
goto L521;
L522:
HEAP[(int)H] = 93;
H = H + 1;
/* Terminar Print array prof N */
t891 = t891 + 1;
if(t891 >= t890) goto t892;
HEAP[(int)H] = 44;
H = H + 1;
t892:
goto L519;
L520:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L515:
t886 = HEAP[(int)t885 ];
if(t886 == -1) goto L518;
HEAP[(int)H] = t886;
H = H + 1;
t885 = t885 + 1;
goto L515;
/* Salida print Complex */
L518:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t910 = t881  ;
L528:
t911 = HEAP[(int)t910 ];
if(t911 != -1) goto L529;
goto L530;
L529:
printf("%c",(char)t911);
t910 = t910 + 1;
goto L528;
L530:
printf("%c",10);
/* Primitivo tipo STR: "" */
t912 = H  ;
HEAP[(int)H] = -1;
H = H + 1;
/* Print de un String o CHAR */
t913 = t912  ;
L531:
t914 = HEAP[(int)t913 ];
if(t914 != -1) goto L532;
goto L533;
L532:
printf("%c",(char)t914);
t913 = t913 + 1;
goto L531;
L533:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t915 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Acceso al elemento de un vector */
t917 = 0;
P = P - t917;
t918 = P + 4;
P = P + t917;
t919 = STACK[(int)t918];
/* Tamanio */
t920 = HEAP[(int)t919 ];
t919 = t919 + 1;
/* Saltarse el capacity */
t919 = t919 + 1;
if(0 >= t920) goto L534;
if(0 < 0) goto L534;
t922 = t919 + 0;
t921 = HEAP[(int)t922 ];
goto L535;
L534:
printf("%c",66);
printf("%c",111);
printf("%c",117);
printf("%c",110);
printf("%c",100);
printf("%c",32);
printf("%c",69);
printf("%c",114);
printf("%c",114);
printf("%c",111);
printf("%c",114);
printf("%c",10);
t921 = 0;
L535:
/* Para saber donde iniciar a imprimir luego del proceso */
t916 = H;
/* Print Complex P.1 */
t923 = t915  ;
L536:
t924 = HEAP[(int)t923 ];
if(t924 == (char)123) goto L539;
HEAP[(int)H] = t924;
H = H + 1;
t923 = t923 + 1;
goto L536;
/* Print Complex P.2 */
L539:
t923 = t923 + 1;
L537:
t924 = HEAP[(int)t923 ];
if(t924 == (char)125) goto L540;
t923 = t923 + 1;
goto L537;
/* Print Complex P.3 */
L540:
t923 = t923 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof 1 */
t929 = 0;
t925 = t921;
/* Tamanio */
t928 = HEAP[(int)t925 ];
t925 = t925 + 1;
t925 = t925 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L542:
if(t929 >= t928) goto L543;
t927 = t925 + t929;
t926 = HEAP[(int)t927 ];
/* Num to String */
t931 = t926;
/* Por si es Negativo  */
if(t931 >= 0) goto L544;
t931 = t931 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L544:
t932 = H;
t933 = t931  ;
L545:
t934 = t933 / 10;
t935 = (int)t934;
if(t935 == 0) goto L546;
t936 = (int)t933%10;
t933 = t935;
HEAP[(int)H] = (int)t936 +48;
H = H + 1;
goto L545;
L546:
HEAP[(int)H] = (int)t933+48;
H = H + 1;
/* sort_revers */
t937 = t932;
t938 = H-1;
L547:
if(t937 >= t938) goto L548;
t939 = HEAP[(int)t938 ];
t940 = HEAP[(int)t937 ];
HEAP[(int)t937] = t939;
HEAP[(int)t938] = t940;
t937 = t937 + 1;
t938 = t938 - 1;
goto L547;
L548:
t929 = t929 + 1;
/* Para evitar poner una comma extra */
if(t929 >= t928) goto t930;
HEAP[(int)H] = 44;
H = H + 1;
t930:
goto L542;
L543:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L538:
t924 = HEAP[(int)t923 ];
if(t924 == -1) goto L541;
HEAP[(int)H] = t924;
H = H + 1;
t923 = t923 + 1;
goto L538;
/* Salida print Complex */
L541:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t942 = t916  ;
L549:
t943 = HEAP[(int)t942 ];
if(t943 != -1) goto L550;
goto L551;
L550:
printf("%c",(char)t943);
t942 = t942 + 1;
goto L549;
L551:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t944 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Acceso al elemento de un vector */
t946 = 0;
P = P - t946;
t947 = P + 4;
P = P + t946;
t948 = STACK[(int)t947];
/* Tamanio */
t949 = HEAP[(int)t948 ];
t948 = t948 + 1;
/* Saltarse el capacity */
t948 = t948 + 1;
if(1 >= t949) goto L552;
if(1 < 0) goto L552;
t951 = t948 + 1;
t950 = HEAP[(int)t951 ];
goto L553;
L552:
printf("%c",66);
printf("%c",111);
printf("%c",117);
printf("%c",110);
printf("%c",100);
printf("%c",32);
printf("%c",69);
printf("%c",114);
printf("%c",114);
printf("%c",111);
printf("%c",114);
printf("%c",10);
t950 = 0;
L553:
/* Para saber donde iniciar a imprimir luego del proceso */
t945 = H;
/* Print Complex P.1 */
t952 = t944  ;
L554:
t953 = HEAP[(int)t952 ];
if(t953 == (char)123) goto L557;
HEAP[(int)H] = t953;
H = H + 1;
t952 = t952 + 1;
goto L554;
/* Print Complex P.2 */
L557:
t952 = t952 + 1;
L555:
t953 = HEAP[(int)t952 ];
if(t953 == (char)125) goto L558;
t952 = t952 + 1;
goto L555;
/* Print Complex P.3 */
L558:
t952 = t952 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof 1 */
t958 = 0;
t954 = t950;
/* Tamanio */
t957 = HEAP[(int)t954 ];
t954 = t954 + 1;
t954 = t954 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L560:
if(t958 >= t957) goto L561;
t956 = t954 + t958;
t955 = HEAP[(int)t956 ];
/* Num to String */
t960 = t955;
/* Por si es Negativo  */
if(t960 >= 0) goto L562;
t960 = t960 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L562:
t961 = H;
t962 = t960  ;
L563:
t963 = t962 / 10;
t964 = (int)t963;
if(t964 == 0) goto L564;
t965 = (int)t962%10;
t962 = t964;
HEAP[(int)H] = (int)t965 +48;
H = H + 1;
goto L563;
L564:
HEAP[(int)H] = (int)t962+48;
H = H + 1;
/* sort_revers */
t966 = t961;
t967 = H-1;
L565:
if(t966 >= t967) goto L566;
t968 = HEAP[(int)t967 ];
t969 = HEAP[(int)t966 ];
HEAP[(int)t966] = t968;
HEAP[(int)t967] = t969;
t966 = t966 + 1;
t967 = t967 - 1;
goto L565;
L566:
t958 = t958 + 1;
/* Para evitar poner una comma extra */
if(t958 >= t957) goto t959;
HEAP[(int)H] = 44;
H = H + 1;
t959:
goto L560;
L561:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L556:
t953 = HEAP[(int)t952 ];
if(t953 == -1) goto L559;
HEAP[(int)H] = t953;
H = H + 1;
t952 = t952 + 1;
goto L556;
/* Salida print Complex */
L559:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t971 = t945  ;
L567:
t972 = HEAP[(int)t971 ];
if(t972 != -1) goto L568;
goto L569;
L568:
printf("%c",(char)t972);
t971 = t971 + 1;
goto L567;
L569:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t973 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Acceso al elemento de un vector */
t975 = 0;
P = P - t975;
t976 = P + 4;
P = P + t975;
t977 = STACK[(int)t976];
/* Tamanio */
t978 = HEAP[(int)t977 ];
t977 = t977 + 1;
/* Saltarse el capacity */
t977 = t977 + 1;
if(2 >= t978) goto L570;
if(2 < 0) goto L570;
t980 = t977 + 2;
t979 = HEAP[(int)t980 ];
goto L571;
L570:
printf("%c",66);
printf("%c",111);
printf("%c",117);
printf("%c",110);
printf("%c",100);
printf("%c",32);
printf("%c",69);
printf("%c",114);
printf("%c",114);
printf("%c",111);
printf("%c",114);
printf("%c",10);
t979 = 0;
L571:
/* Para saber donde iniciar a imprimir luego del proceso */
t974 = H;
/* Print Complex P.1 */
t981 = t973  ;
L572:
t982 = HEAP[(int)t981 ];
if(t982 == (char)123) goto L575;
HEAP[(int)H] = t982;
H = H + 1;
t981 = t981 + 1;
goto L572;
/* Print Complex P.2 */
L575:
t981 = t981 + 1;
L573:
t982 = HEAP[(int)t981 ];
if(t982 == (char)125) goto L576;
t981 = t981 + 1;
goto L573;
/* Print Complex P.3 */
L576:
t981 = t981 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof 1 */
t987 = 0;
t983 = t979;
/* Tamanio */
t986 = HEAP[(int)t983 ];
t983 = t983 + 1;
t983 = t983 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L578:
if(t987 >= t986) goto L579;
t985 = t983 + t987;
t984 = HEAP[(int)t985 ];
/* Num to String */
t989 = t984;
/* Por si es Negativo  */
if(t989 >= 0) goto L580;
t989 = t989 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L580:
t990 = H;
t991 = t989  ;
L581:
t992 = t991 / 10;
t993 = (int)t992;
if(t993 == 0) goto L582;
t994 = (int)t991%10;
t991 = t993;
HEAP[(int)H] = (int)t994 +48;
H = H + 1;
goto L581;
L582:
HEAP[(int)H] = (int)t991+48;
H = H + 1;
/* sort_revers */
t995 = t990;
t996 = H-1;
L583:
if(t995 >= t996) goto L584;
t997 = HEAP[(int)t996 ];
t998 = HEAP[(int)t995 ];
HEAP[(int)t995] = t997;
HEAP[(int)t996] = t998;
t995 = t995 + 1;
t996 = t996 - 1;
goto L583;
L584:
t987 = t987 + 1;
/* Para evitar poner una comma extra */
if(t987 >= t986) goto t988;
HEAP[(int)H] = 44;
H = H + 1;
t988:
goto L578;
L579:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L574:
t982 = HEAP[(int)t981 ];
if(t982 == -1) goto L577;
HEAP[(int)H] = t982;
H = H + 1;
t981 = t981 + 1;
goto L574;
/* Salida print Complex */
L577:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t1000 = t974  ;
L585:
t1001 = HEAP[(int)t1000 ];
if(t1001 != -1) goto L586;
goto L587;
L586:
printf("%c",(char)t1001);
t1000 = t1000 + 1;
goto L585;
L587:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t1002 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Acceso al elemento de un vector */
t1004 = 0;
P = P - t1004;
t1005 = P + 4;
P = P + t1004;
t1006 = STACK[(int)t1005];
/* Tamanio */
t1007 = HEAP[(int)t1006 ];
t1006 = t1006 + 1;
/* Saltarse el capacity */
t1006 = t1006 + 1;
if(3 >= t1007) goto L588;
if(3 < 0) goto L588;
t1009 = t1006 + 3;
t1008 = HEAP[(int)t1009 ];
goto L589;
L588:
printf("%c",66);
printf("%c",111);
printf("%c",117);
printf("%c",110);
printf("%c",100);
printf("%c",32);
printf("%c",69);
printf("%c",114);
printf("%c",114);
printf("%c",111);
printf("%c",114);
printf("%c",10);
t1008 = 0;
L589:
/* Para saber donde iniciar a imprimir luego del proceso */
t1003 = H;
/* Print Complex P.1 */
t1010 = t1002  ;
L590:
t1011 = HEAP[(int)t1010 ];
if(t1011 == (char)123) goto L593;
HEAP[(int)H] = t1011;
H = H + 1;
t1010 = t1010 + 1;
goto L590;
/* Print Complex P.2 */
L593:
t1010 = t1010 + 1;
L591:
t1011 = HEAP[(int)t1010 ];
if(t1011 == (char)125) goto L594;
t1010 = t1010 + 1;
goto L591;
/* Print Complex P.3 */
L594:
t1010 = t1010 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof 1 */
t1016 = 0;
t1012 = t1008;
/* Tamanio */
t1015 = HEAP[(int)t1012 ];
t1012 = t1012 + 1;
t1012 = t1012 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L596:
if(t1016 >= t1015) goto L597;
t1014 = t1012 + t1016;
t1013 = HEAP[(int)t1014 ];
/* Num to String */
t1018 = t1013;
/* Por si es Negativo  */
if(t1018 >= 0) goto L598;
t1018 = t1018 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L598:
t1019 = H;
t1020 = t1018  ;
L599:
t1021 = t1020 / 10;
t1022 = (int)t1021;
if(t1022 == 0) goto L600;
t1023 = (int)t1020%10;
t1020 = t1022;
HEAP[(int)H] = (int)t1023 +48;
H = H + 1;
goto L599;
L600:
HEAP[(int)H] = (int)t1020+48;
H = H + 1;
/* sort_revers */
t1024 = t1019;
t1025 = H-1;
L601:
if(t1024 >= t1025) goto L602;
t1026 = HEAP[(int)t1025 ];
t1027 = HEAP[(int)t1024 ];
HEAP[(int)t1024] = t1026;
HEAP[(int)t1025] = t1027;
t1024 = t1024 + 1;
t1025 = t1025 - 1;
goto L601;
L602:
t1016 = t1016 + 1;
/* Para evitar poner una comma extra */
if(t1016 >= t1015) goto t1017;
HEAP[(int)H] = 44;
H = H + 1;
t1017:
goto L596;
L597:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L592:
t1011 = HEAP[(int)t1010 ];
if(t1011 == -1) goto L595;
HEAP[(int)H] = t1011;
H = H + 1;
t1010 = t1010 + 1;
goto L592;
/* Salida print Complex */
L595:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t1029 = t1003  ;
L603:
t1030 = HEAP[(int)t1029 ];
if(t1030 != -1) goto L604;
goto L605;
L604:
printf("%c",(char)t1030);
t1029 = t1029 + 1;
goto L603;
L605:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t1031 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Acceso al elemento de un vector */
t1033 = 0;
P = P - t1033;
t1034 = P + 4;
P = P + t1033;
t1035 = STACK[(int)t1034];
/* Tamanio */
t1036 = HEAP[(int)t1035 ];
t1035 = t1035 + 1;
/* Saltarse el capacity */
t1035 = t1035 + 1;
if(4 >= t1036) goto L606;
if(4 < 0) goto L606;
t1038 = t1035 + 4;
t1037 = HEAP[(int)t1038 ];
goto L607;
L606:
printf("%c",66);
printf("%c",111);
printf("%c",117);
printf("%c",110);
printf("%c",100);
printf("%c",32);
printf("%c",69);
printf("%c",114);
printf("%c",114);
printf("%c",111);
printf("%c",114);
printf("%c",10);
t1037 = 0;
L607:
/* Para saber donde iniciar a imprimir luego del proceso */
t1032 = H;
/* Print Complex P.1 */
t1039 = t1031  ;
L608:
t1040 = HEAP[(int)t1039 ];
if(t1040 == (char)123) goto L611;
HEAP[(int)H] = t1040;
H = H + 1;
t1039 = t1039 + 1;
goto L608;
/* Print Complex P.2 */
L611:
t1039 = t1039 + 1;
L609:
t1040 = HEAP[(int)t1039 ];
if(t1040 == (char)125) goto L612;
t1039 = t1039 + 1;
goto L609;
/* Print Complex P.3 */
L612:
t1039 = t1039 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof 1 */
t1045 = 0;
t1041 = t1037;
/* Tamanio */
t1044 = HEAP[(int)t1041 ];
t1041 = t1041 + 1;
t1041 = t1041 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L614:
if(t1045 >= t1044) goto L615;
t1043 = t1041 + t1045;
t1042 = HEAP[(int)t1043 ];
/* Num to String */
t1047 = t1042;
/* Por si es Negativo  */
if(t1047 >= 0) goto L616;
t1047 = t1047 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L616:
t1048 = H;
t1049 = t1047  ;
L617:
t1050 = t1049 / 10;
t1051 = (int)t1050;
if(t1051 == 0) goto L618;
t1052 = (int)t1049%10;
t1049 = t1051;
HEAP[(int)H] = (int)t1052 +48;
H = H + 1;
goto L617;
L618:
HEAP[(int)H] = (int)t1049+48;
H = H + 1;
/* sort_revers */
t1053 = t1048;
t1054 = H-1;
L619:
if(t1053 >= t1054) goto L620;
t1055 = HEAP[(int)t1054 ];
t1056 = HEAP[(int)t1053 ];
HEAP[(int)t1053] = t1055;
HEAP[(int)t1054] = t1056;
t1053 = t1053 + 1;
t1054 = t1054 - 1;
goto L619;
L620:
t1045 = t1045 + 1;
/* Para evitar poner una comma extra */
if(t1045 >= t1044) goto t1046;
HEAP[(int)H] = 44;
H = H + 1;
t1046:
goto L614;
L615:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L610:
t1040 = HEAP[(int)t1039 ];
if(t1040 == -1) goto L613;
HEAP[(int)H] = t1040;
H = H + 1;
t1039 = t1039 + 1;
goto L610;
/* Salida print Complex */
L613:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t1058 = t1032  ;
L621:
t1059 = HEAP[(int)t1058 ];
if(t1059 != -1) goto L622;
goto L623;
L622:
printf("%c",(char)t1059);
t1058 = t1058 + 1;
goto L621;
L623:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t1060 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Acceso al elemento de un vector */
t1062 = 0;
P = P - t1062;
t1063 = P + 4;
P = P + t1062;
t1064 = STACK[(int)t1063];
/* Tamanio */
t1065 = HEAP[(int)t1064 ];
t1064 = t1064 + 1;
/* Saltarse el capacity */
t1064 = t1064 + 1;
if(4 >= t1065) goto L624;
if(4 < 0) goto L624;
t1067 = t1064 + 4;
t1066 = HEAP[(int)t1067 ];
t1064 = t1066;
/* Tamanio */
t1065 = HEAP[(int)t1064 ];
t1064 = t1064 + 1;
t1064 = t1064 + 1;
if(8 >= t1065) goto L624;
if(8 < 0) goto L624;
t1067 = t1064 + 8;
t1066 = HEAP[(int)t1067 ];
goto L625;
L624:
printf("%c",66);
printf("%c",111);
printf("%c",117);
printf("%c",110);
printf("%c",100);
printf("%c",32);
printf("%c",69);
printf("%c",114);
printf("%c",114);
printf("%c",111);
printf("%c",114);
printf("%c",10);
t1066 = 0;
L625:
/* Para saber donde iniciar a imprimir luego del proceso */
t1061 = H;
/* Print Complex P.1 */
t1068 = t1060  ;
L626:
t1069 = HEAP[(int)t1068 ];
if(t1069 == (char)123) goto L629;
HEAP[(int)H] = t1069;
H = H + 1;
t1068 = t1068 + 1;
goto L626;
/* Print Complex P.2 */
L629:
t1068 = t1068 + 1;
L627:
t1069 = HEAP[(int)t1068 ];
if(t1069 == (char)125) goto L630;
t1068 = t1068 + 1;
goto L627;
/* Print Complex P.3 */
L630:
t1068 = t1068 + 1;
/* Num to String */
t1070 = t1066;
/* Por si es Negativo  */
if(t1070 >= 0) goto L632;
t1070 = t1070 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L632:
t1071 = H;
t1072 = t1070  ;
L633:
t1073 = t1072 / 10;
t1074 = (int)t1073;
if(t1074 == 0) goto L634;
t1075 = (int)t1072%10;
t1072 = t1074;
HEAP[(int)H] = (int)t1075 +48;
H = H + 1;
goto L633;
L634:
HEAP[(int)H] = (int)t1072+48;
H = H + 1;
/* sort_revers */
t1076 = t1071;
t1077 = H-1;
L635:
if(t1076 >= t1077) goto L636;
t1078 = HEAP[(int)t1077 ];
t1079 = HEAP[(int)t1076 ];
HEAP[(int)t1076] = t1078;
HEAP[(int)t1077] = t1079;
t1076 = t1076 + 1;
t1077 = t1077 - 1;
goto L635;
L636:
/* Print Complex P.4 */
L628:
t1069 = HEAP[(int)t1068 ];
if(t1069 == -1) goto L631;
HEAP[(int)H] = t1069;
H = H + 1;
t1068 = t1068 + 1;
goto L628;
/* Salida print Complex */
L631:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t1081 = t1061  ;
L637:
t1082 = HEAP[(int)t1081 ];
if(t1082 != -1) goto L638;
goto L639;
L638:
printf("%c",(char)t1082);
t1081 = t1081 + 1;
goto L637;
L639:
printf("%c",10);
/* Primitivo tipo STR: "" */
t1083 = H  ;
HEAP[(int)H] = -1;
H = H + 1;
/* Print de un String o CHAR */
t1084 = t1083  ;
L640:
t1085 = HEAP[(int)t1084 ];
if(t1085 != -1) goto L641;
goto L642;
L641:
printf("%c",(char)t1085);
t1084 = t1084 + 1;
goto L640;
L642:
printf("%c",10);
/* Declaracion de Vector: vec */
/* Vector con vec! */
/* Exp Vec! */
/* Primitivo tipo STR: "Hola" */
t1087 = H  ;
HEAP[(int)H] = 72;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Primitivo tipo STR: "!" */
t1088 = H  ;
HEAP[(int)H] = 33;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Primitivo tipo STR: "Sale" */
t1089 = H  ;
HEAP[(int)H] = 83;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Primitivo tipo STR: "Este" */
t1090 = H  ;
HEAP[(int)H] = 69;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Primitivo tipo STR: "Semestre" */
t1091 = H  ;
HEAP[(int)H] = 83;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 109;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 114;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Primitivo tipo STR: "2022" */
t1092 = H  ;
HEAP[(int)H] = 50;
H = H + 1;
HEAP[(int)H] = 48;
H = H + 1;
HEAP[(int)H] = 50;
H = H + 1;
HEAP[(int)H] = 50;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
t1086 = H;
/* Tamanio Vec! */
HEAP[(int)H] = 6;
H = H + 1;
/* --------------- */
/* Capacity del vec */
HEAP[(int)H] = 6;
H = H + 1;
/* --------------- */
HEAP[(int)H] = t1087;
H = H + 1;
HEAP[(int)H] = t1088;
H = H + 1;
HEAP[(int)H] = t1089;
H = H + 1;
HEAP[(int)H] = t1090;
H = H + 1;
HEAP[(int)H] = t1091;
H = H + 1;
HEAP[(int)H] = t1092;
H = H + 1;
t1093 = P + 5;
STACK[(int)t1093] = t1086;
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t1094 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Logicas */
/* Logica: Or */
/* Contains Vector vec */
t1096 = 0;
P = P - t1096;
t1101 = P + 5;
P = P + t1096;
t1097 = STACK[(int)t1101];
t1098 = HEAP[(int)t1097 ];
t1097 = t1097 + 1;
t1097 = t1097 + 1;
t1100 = 0;
L646:
if(t1100 >= t1098) goto L645;
t1099 = HEAP[(int)t1097 ];
t1097 = t1097 + 1;
t1100 = t1100 + 1;
/* Operaciones Relacionales */
/* Primitivo tipo STR: "Semestre" */
t1102 = H  ;
HEAP[(int)H] = 83;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 109;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 114;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
t1103 = t1099;
t1104 = t1102;
t1105 = t1103;
L650:
t1106 = HEAP[(int)t1104 ];
t1107 = HEAP[(int)t1105 ];
t1104 = t1104 + 1;
t1105 = t1105 + 1;
if(t1106 == -1) goto L651;
if(t1107 == -1) goto L648;
if(t1106 == t1107) goto L650;
goto L648;
L651:
if(t1107 == -1) goto L647;
goto L648;
L647:
goto L643;
L648:
goto L646;
/* END Contains */
L645:
/* Contains Vector vec */
t1108 = 0;
P = P - t1108;
t1113 = P + 5;
P = P + t1108;
t1109 = STACK[(int)t1113];
t1110 = HEAP[(int)t1109 ];
t1109 = t1109 + 1;
t1109 = t1109 + 1;
t1112 = 0;
L652:
if(t1112 >= t1110) goto L644;
t1111 = HEAP[(int)t1109 ];
t1109 = t1109 + 1;
t1112 = t1112 + 1;
/* Operaciones Relacionales */
/* Primitivo tipo STR: "2023" */
t1114 = H  ;
HEAP[(int)H] = 50;
H = H + 1;
HEAP[(int)H] = 48;
H = H + 1;
HEAP[(int)H] = 50;
H = H + 1;
HEAP[(int)H] = 51;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
t1115 = t1111;
t1116 = t1114;
t1117 = t1115;
L656:
t1118 = HEAP[(int)t1116 ];
t1119 = HEAP[(int)t1117 ];
t1116 = t1116 + 1;
t1117 = t1117 + 1;
if(t1118 == -1) goto L657;
if(t1119 == -1) goto L654;
if(t1118 == t1119) goto L656;
goto L654;
L657:
if(t1119 == -1) goto L653;
goto L654;
L653:
goto L643;
L654:
goto L652;
/* END Contains */
/* Imprimir Expresion Booleana */
/* Print de un Boolean */
L643:
t1120 = H;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 114;
H = H + 1;
HEAP[(int)H] = 117;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
goto L658;
L644:
t1120 = H;
HEAP[(int)H] = 102;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
L658:
HEAP[(int)H] = -1;
H = H + 1;
/* Para saber donde iniciar a imprimir luego del proceso */
t1095 = H;
/* Print Complex P.1 */
t1121 = t1094  ;
L659:
t1122 = HEAP[(int)t1121 ];
if(t1122 == (char)123) goto L662;
HEAP[(int)H] = t1122;
H = H + 1;
t1121 = t1121 + 1;
goto L659;
/* Print Complex P.2 */
L662:
t1121 = t1121 + 1;
L660:
t1122 = HEAP[(int)t1121 ];
if(t1122 == (char)125) goto L663;
t1121 = t1121 + 1;
goto L660;
/* Print Complex P.3 */
L663:
t1121 = t1121 + 1;
t1123 = t1120  ;
L665:
t1124 = HEAP[(int)t1123 ];
if(t1124 == -1) goto L666;
HEAP[(int)H] = t1124;
H = H + 1;
t1123 = t1123 + 1;
goto L665;
L666:
/* Print Complex P.4 */
L661:
t1122 = HEAP[(int)t1121 ];
if(t1122 == -1) goto L664;
HEAP[(int)H] = t1122;
H = H + 1;
t1121 = t1121 + 1;
goto L661;
/* Salida print Complex */
L664:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t1126 = t1095  ;
L667:
t1127 = HEAP[(int)t1126 ];
if(t1127 != -1) goto L668;
goto L669;
L668:
printf("%c",(char)t1127);
t1126 = t1126 + 1;
goto L667;
L669:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t1128 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Logicas */
/* Logica: And */
/* Contains Vector vec */
t1130 = 0;
P = P - t1130;
t1135 = P + 5;
P = P + t1130;
t1131 = STACK[(int)t1135];
t1132 = HEAP[(int)t1131 ];
t1131 = t1131 + 1;
t1131 = t1131 + 1;
t1134 = 0;
L673:
if(t1134 >= t1132) goto L671;
t1133 = HEAP[(int)t1131 ];
t1131 = t1131 + 1;
t1134 = t1134 + 1;
/* Operaciones Relacionales */
/* Primitivo tipo STR: "Semestre" */
t1136 = H  ;
HEAP[(int)H] = 83;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 109;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 114;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
t1137 = t1133;
t1138 = t1136;
t1139 = t1137;
L677:
t1140 = HEAP[(int)t1138 ];
t1141 = HEAP[(int)t1139 ];
t1138 = t1138 + 1;
t1139 = t1139 + 1;
if(t1140 == -1) goto L678;
if(t1141 == -1) goto L675;
if(t1140 == t1141) goto L677;
goto L675;
L678:
if(t1141 == -1) goto L674;
goto L675;
L674:
goto L672;
L675:
goto L673;
/* END Contains */
L672:
/* Contains Vector vec */
t1142 = 0;
P = P - t1142;
t1147 = P + 5;
P = P + t1142;
t1143 = STACK[(int)t1147];
t1144 = HEAP[(int)t1143 ];
t1143 = t1143 + 1;
t1143 = t1143 + 1;
t1146 = 0;
L679:
if(t1146 >= t1144) goto L671;
t1145 = HEAP[(int)t1143 ];
t1143 = t1143 + 1;
t1146 = t1146 + 1;
/* Operaciones Relacionales */
/* Primitivo tipo STR: "2023" */
t1148 = H  ;
HEAP[(int)H] = 50;
H = H + 1;
HEAP[(int)H] = 48;
H = H + 1;
HEAP[(int)H] = 50;
H = H + 1;
HEAP[(int)H] = 51;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
t1149 = t1145;
t1150 = t1148;
t1151 = t1149;
L683:
t1152 = HEAP[(int)t1150 ];
t1153 = HEAP[(int)t1151 ];
t1150 = t1150 + 1;
t1151 = t1151 + 1;
if(t1152 == -1) goto L684;
if(t1153 == -1) goto L681;
if(t1152 == t1153) goto L683;
goto L681;
L684:
if(t1153 == -1) goto L680;
goto L681;
L680:
goto L670;
L681:
goto L679;
/* END Contains */
/* Imprimir Expresion Booleana */
/* Print de un Boolean */
L670:
t1154 = H;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 114;
H = H + 1;
HEAP[(int)H] = 117;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
goto L685;
L671:
t1154 = H;
HEAP[(int)H] = 102;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
L685:
HEAP[(int)H] = -1;
H = H + 1;
/* Para saber donde iniciar a imprimir luego del proceso */
t1129 = H;
/* Print Complex P.1 */
t1155 = t1128  ;
L686:
t1156 = HEAP[(int)t1155 ];
if(t1156 == (char)123) goto L689;
HEAP[(int)H] = t1156;
H = H + 1;
t1155 = t1155 + 1;
goto L686;
/* Print Complex P.2 */
L689:
t1155 = t1155 + 1;
L687:
t1156 = HEAP[(int)t1155 ];
if(t1156 == (char)125) goto L690;
t1155 = t1155 + 1;
goto L687;
/* Print Complex P.3 */
L690:
t1155 = t1155 + 1;
t1157 = t1154  ;
L692:
t1158 = HEAP[(int)t1157 ];
if(t1158 == -1) goto L693;
HEAP[(int)H] = t1158;
H = H + 1;
t1157 = t1157 + 1;
goto L692;
L693:
/* Print Complex P.4 */
L688:
t1156 = HEAP[(int)t1155 ];
if(t1156 == -1) goto L691;
HEAP[(int)H] = t1156;
H = H + 1;
t1155 = t1155 + 1;
goto L688;
/* Salida print Complex */
L691:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t1160 = t1129  ;
L694:
t1161 = HEAP[(int)t1160 ];
if(t1161 != -1) goto L695;
goto L696;
L695:
printf("%c",(char)t1161);
t1160 = t1160 + 1;
goto L694;
L696:
printf("%c",10);
/* Instruccion Print */
/* Primitivo tipo STR: "{}" */
t1162 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Contains Vector vec */
t1164 = 0;
P = P - t1164;
t1169 = P + 5;
P = P + t1164;
t1165 = STACK[(int)t1169];
t1166 = HEAP[(int)t1165 ];
t1165 = t1165 + 1;
t1165 = t1165 + 1;
t1168 = 0;
L699:
if(t1168 >= t1166) goto L697;
t1167 = HEAP[(int)t1165 ];
t1165 = t1165 + 1;
t1168 = t1168 + 1;
/* Operaciones Relacionales */
/* Primitivo tipo STR: "Hola" */
t1170 = H  ;
HEAP[(int)H] = 72;
H = H + 1;
HEAP[(int)H] = 111;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
t1171 = t1167;
t1172 = t1170;
t1173 = t1171;
L703:
t1174 = HEAP[(int)t1172 ];
t1175 = HEAP[(int)t1173 ];
t1172 = t1172 + 1;
t1173 = t1173 + 1;
if(t1174 == -1) goto L704;
if(t1175 == -1) goto L701;
if(t1174 == t1175) goto L703;
goto L701;
L704:
if(t1175 == -1) goto L700;
goto L701;
L700:
goto L698;
L701:
goto L699;
/* END Contains */
/* Imprimir Expresion Booleana */
/* Print de un Boolean */
L698:
t1176 = H;
HEAP[(int)H] = 116;
H = H + 1;
HEAP[(int)H] = 114;
H = H + 1;
HEAP[(int)H] = 117;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
goto L705;
L697:
t1176 = H;
HEAP[(int)H] = 102;
H = H + 1;
HEAP[(int)H] = 97;
H = H + 1;
HEAP[(int)H] = 108;
H = H + 1;
HEAP[(int)H] = 115;
H = H + 1;
HEAP[(int)H] = 101;
H = H + 1;
L705:
HEAP[(int)H] = -1;
H = H + 1;
/* Para saber donde iniciar a imprimir luego del proceso */
t1163 = H;
/* Print Complex P.1 */
t1177 = t1162  ;
L706:
t1178 = HEAP[(int)t1177 ];
if(t1178 == (char)123) goto L709;
HEAP[(int)H] = t1178;
H = H + 1;
t1177 = t1177 + 1;
goto L706;
/* Print Complex P.2 */
L709:
t1177 = t1177 + 1;
L707:
t1178 = HEAP[(int)t1177 ];
if(t1178 == (char)125) goto L710;
t1177 = t1177 + 1;
goto L707;
/* Print Complex P.3 */
L710:
t1177 = t1177 + 1;
t1179 = t1176  ;
L712:
t1180 = HEAP[(int)t1179 ];
if(t1180 == -1) goto L713;
HEAP[(int)H] = t1180;
H = H + 1;
t1179 = t1179 + 1;
goto L712;
L713:
/* Print Complex P.4 */
L708:
t1178 = HEAP[(int)t1177 ];
if(t1178 == -1) goto L711;
HEAP[(int)H] = t1178;
H = H + 1;
t1177 = t1177 + 1;
goto L708;
/* Salida print Complex */
L711:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t1182 = t1163  ;
L714:
t1183 = HEAP[(int)t1182 ];
if(t1183 != -1) goto L715;
goto L716;
L715:
printf("%c",(char)t1183);
t1182 = t1182 + 1;
goto L714;
L716:
printf("%c",10);
return 0;
}
