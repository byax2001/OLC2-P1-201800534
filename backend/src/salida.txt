#include <stdio.h>
float HEAP[78000];
float STACK[10000];
float P;
float H;
float t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,t17,t18,t19,t20,t21,t22,t23,t24,t25,t26,t27,t28,t29,t30,t31,t32,t33;

void ordIntercambio(){{
/* Declaracion var: i */
t3 = P + 2;
STACK[(int)t3] = 0;
/* Declaracion var: j */
t4 = P + 3;
STACK[(int)t4] = 0;
L0:
return; 
}} 

int main(){
/* Declaracion de arreglo: arr1 */
t0 = 5;
/* Exp Arreglo */
t1 = H;
/* Tamanio Arreglo */
HEAP[(int)H] = 5;
/* --------------- */
H = H + 1;
HEAP[(int)H] = 25;
H = H + 1;
HEAP[(int)H] = 2;
H = H + 1;
HEAP[(int)H] = 17;
H = H + 1;
HEAP[(int)H] = 30;
H = H + 1;
HEAP[(int)H] = 1;
H = H + 1;
t2 = P + 0;
STACK[(int)t2] = t1;
/* Llamada a funcion: ordIntercambio */
t0 = P + 1;
P = P + 1;
ordIntercambio();
P = P - 1;
t5 = P + 1;
t6 = STACK[(int)t5];
/* Instruccion Print */
/* Primitivo tipo STR: "{:?}" */
t7 = H  ;
HEAP[(int)H] = 123;
H = H + 1;
HEAP[(int)H] = 58;
H = H + 1;
HEAP[(int)H] = 63;
H = H + 1;
HEAP[(int)H] = 125;
H = H + 1;
HEAP[(int)H] = -1;
H = H + 1;
/* Por si la expresiona imprimir es booleana */
t9 = H;
/* ID EXPRESION: arr1 */
P = P - t10;
t12 = P + 0;
P = P + t10;
t11 = STACK[(int)t12];
/* Para saber donde iniciar a imprimir luego del proceso */
t8 = H;
/* Print Complex P.1 */
t13 = t7  ;
L1:
t14 = HEAP[(int)t13 ];
if(t14 == (char)123) goto L4;
HEAP[(int)H] = t14;
H = H + 1;
t13 = t13 + 1;
goto L1;
/* Print Complex P.2 */
L4:
t13 = t13 + 1;
L2:
t14 = HEAP[(int)t13 ];
if(t14 == (char)125) goto L5;
t13 = t13 + 1;
goto L2;
/* Print Complex P.3 */
L5:
t13 = t13 + 1;
/* INGRESO DE ARRAY AL STRING */
/* Print array prof 1 */
t19 = 0;
t15 = t11;
/* Tamanio */
t18 = HEAP[(int)t15 ];
t15 = t15 + 1;
HEAP[(int)H] = 91;
H = H + 1;
L7:
if(t19 >= t18) goto L8;
t17 = t15 + t19;
t16 = HEAP[(int)t17 ];
/* Num to String */
t21 = t16;
/* Por si es Negativo  */
if(t21 >= 0) goto L9;
t21 = t21 * -1;
HEAP[(int)H] = 45;
H = H + 1;
L9:
t22 = H;
t23 = t21  ;
L10:
t24 = t23 / 10;
t25 = (int)t24;
if(t25 == 0) goto L11;
t26 = (int)t23%10;
t23 = t25;
HEAP[(int)H] = (int)t26 +48;
H = H + 1;
goto L10;
L11:
HEAP[(int)H] = (int)t23+48;
H = H + 1;
/* sort_revers */
t27 = t22;
t28 = H-1;
L12:
if(t27 >= t28) goto L13;
t29 = HEAP[(int)t28 ];
t30 = HEAP[(int)t27 ];
HEAP[(int)t27] = t29;
HEAP[(int)t28] = t30;
t27 = t27 + 1;
t28 = t28 - 1;
goto L12;
L13:
t19 = t19 + 1;
/* Para evitar poner una comma extra */
if(t19 >= t18) goto t20;
HEAP[(int)H] = 44;
H = H + 1;
t20:
goto L7;
L8:
HEAP[(int)H] = 93;
H = H + 1;
/* Print Complex P.4 */
L3:
t14 = HEAP[(int)t13 ];
if(t14 == -1) goto L6;
HEAP[(int)H] = t14;
H = H + 1;
t13 = t13 + 1;
goto L3;
/* Salida print Complex */
L6:
HEAP[(int)H] = -1;
H = H + 1;
/* Impresion */
t32 = t8  ;
L14:
t33 = HEAP[(int)t32 ];
if(t33 != -1) goto L15;
goto L16;
L15:
printf("%c",(char)t33);
t32 = t32 + 1;
goto L14;
L16:
printf("%c",10);
return 0;
}
